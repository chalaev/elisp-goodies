#+TITLE: useful lisp macros and functions
#+AUTHOR: Oleg Shalaev
#+EMAIL:  oleg@chalaev.com
#+LaTeX_HEADER: \usepackage[russian,english]{babel}
#+LATEX_HEADER: \usepackage[letterpaper,hmargin={1.5cm,1.5cm},vmargin={1.3cm,2cm},nohead,nofoot]{geometry}
#+KEYWORDS: emacs, elisp, common lisp, macros, functions

#+BEGIN_SRC lisp :tangle generated/tests.lisp
(declaim (notinline id))
(defun id(x) x)
#+END_SRC

* Introduction
Notes:
1. Evaluation results are important part of this file, but =github= org-parser does not show them.
   (BTW [[https://notabug.org/shalaev/lisp-goodies/src/master/goodies.org][notabug does show them]] although unformatted.)  Consider opening this file in ~emacs~ instead of watching it online.
2. Sometimes a demonstration of a function might use the definition of another function defined below in this file or another
   file from the ~generated/~ directory, so you might need to =load= those first. And here comes the first example :)
   using =randstr= function defined in [[file:generated/functions.el][generated/functions.el]]:

#+NAME: randstr
#+BEGIN_SRC emacs-lisp
(concat (rand-str 4) ".tmp")
#+END_SRC

For testing puprposes it is useful to convert macro expansions to string:
#+BEGIN_SRC emacs-lisp :tangle generated/macros.el :shebang ";; -*-  lexical-binding: t; -*-"
(defmacro string-from-macro(m)
`(format "%s" (print (macroexpand-1 ,m) #'(lambda(x) (format "%s" x)))))
#+END_SRC

#+BEGIN_SRC lisp :tangle generated/shalaev.lisp
;; empty file needed for Makefile
#+END_SRC

* when-let
** Emacs Lisp
(in latest emacs) =when-let= and =when-let*= are defined in ~subr-x.el~:
#+BEGIN_SRC emacs-lisp :tangle generated/macros.el
(require 'subr-x)
#+END_SRC

=when-let= is one of my most-used macros; it is defined on top of (more general) =when-let-key=:
#+BEGIN_SRC emacs-lisp :tangle generated/macros.el
(unless (< 25 (car (emacs-ver)))
(defmacro when-let-key (key vars &rest body)
  "when with let using standard let-notation, but every item in vars must be a list"
  (if (car vars)
  `(let ((,(caar vars) ,(cadar vars)))
     ,(if (cdr vars)
	  `(when (funcall ,key ,(caar vars))
	     ,(macroexpand-1 `(when-let-key ,key ,(cdr vars) ,@body)))
	(append `(when (funcall ,key ,(caar vars))) body)))
  (if (cdr vars)
      `(when ,(cadar vars)
	     ,(macroexpand-1 `(when-let-key ,key ,(cdr vars) ,@body)))
    (append `(when (funcall ,key ,(cadar vars))) body)))))
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle generated/tests.el
(unless (< 25 (car (emacs-ver)))
(ert-deftest when-let-key()
(should (string= "aba" (when-let-key  #'identity ((a "a") (b (concat a "b")))
  (concat b "a"))))
(should (not (when-let-key  #'identity ((a "a") (b nil)) (concat "z" "a"))))
(should (not (when-let-key  #'identity ((c nil) (a "a") (b nil)) (concat "z" "a"))))))
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle generated/macros.el
(unless (< 25 (car (emacs-ver)))
(defmacro when-let*(vars &rest body)
  "when with let using standard let-notation"
`(when-let-key #'identity
   ,(mapcar #'(lambda(v) (if(listp v) v (list v nil))) vars)
    ,@body)))
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle generated/tests.el
(unless (< 25 (car (emacs-ver)))
(ert-deftest when-let*()
(should (string= "aba" 
   (when-let* ((a "a") (b (concat a "b")))
      (concat b "a"))))
(should (not (when-let* ((a "a") (b)) (concat "z" "a"))))
(should (not (when-let* (c (a "a") b) (concat "z" "a"))))))
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle generated/tests.el
(ert-deftest when-let()
  "Testing here when-let and when-let* defined in subr-x.el"
(should (string= "ba" (when-let (a "a") (concat "b" a))))
(should (string= "ba" (when-let ((a "a")) (concat "b" a))))
(should (string= "ba" (when-let ((a "a") (b "b")) (concat b a))))
(should (string= "aba" (when-let ((a "a") (b (concat a "b"))) (concat b "a"))))
(should (string= "aba" (when-let* ((a "a") (b (concat a "b"))) (concat b "a")))))
#+END_SRC
← =when-let= is /almost/ identical to =when-let*=.

#+BEGIN_SRC emacs-lisp :tangle generated/tests.el
(ert-deftest if-let*()
  "Testing here if-let* defined in subr-x.el"
:expected-result (if (< 25 (car (emacs-ver))) :passed :failed)
(should (= 1 (if-let* ((a 3)) 1 2)))
(should (= 12 (if-let* ((a 3) (b (* 3 a))) (+ a b) (- a b)))))
#+END_SRC

Later I wrote [[needs]] which is more general than =when-let=, and can replace it.

** Common Lisp
CL code is the same:
#+BEGIN_SRC lisp :tangle generated/macros.lisp
(defmacro when-let (vars &rest body)
  "when with let using standard let-notation"
  (if (caar vars)
  `(let ((,(caar vars) ,(cadar vars)))
     ,(if (cdr vars)
	  `(when ,(caar vars)
	     ,(macroexpand-1 `(when-let ,(cdr vars) ,@body)))
	(append `(when ,(caar vars)) body)))
  (if (cdr vars)
      `(when ,(cadar vars)
	     ,(macroexpand-1 `(when-let ,(cdr vars) ,@body)))
    (append `(when ,(cadar vars)) body))))
#+END_SRC

#+BEGIN_SRC lisp :tangle generated/tests.lisp
(deftest when-let
    (when-let ((x (id :ok)))
      (setf x (cons x x))
      x)
  (:ok . :ok))
#+END_SRC

* if-let
** Emacs Lisp
Similarly to [[when-let]], (in latest emacs) =if-let= is defined in ~subr-x.el~.

Like =when-let=, macro =sif-let= is heavily used in my projects.
It is somewhat similar to =when-let=, but offers "else" clause:
#+BEGIN_SRC emacs-lisp :tangle generated/macros.el
(defmacro sif-let (vars ifyes &rest body)
  "if with let using standard let-notation"
  (let ((if-true (s-gensym "it")) (result (s-gensym "r")))
    `(let (,if-true ,result)
       (when-let* ,vars
		 (setf ,if-true t
		  ,result ,ifyes))
       (if ,if-true
	   ,result
	 ,@body))))
#+END_SRC

Usage example:
#+BEGIN_SRC emacs-lisp :results drawer
(print (macroexpand-1 
  '(sif-let ((x 1) (y (1+ x)))
     (+ x y) (- x y) (* x y))))
#+END_SRC

#+RESULTS:
:RESULTS:
(let (it17 r18) (when-let ((x 1) (y (1+ x))) (setf it17 t r18 (+ x y))) (if it17 r18 (- x y) (* x y)))
:END:

** Common Lisp
My =if-let= has almost the same functionality, as [[https://common-lisp.net/project/alexandria/draft/alexandria.html][alexandria:if-let]]
except that instead of single =else-form= there can be multiple forms.

#+BEGIN_SRC lisp :tangle generated/macros.lisp
(defmacro if-let (vars ifyes &rest body)
  "if with let using standard let-notation"
  (let ((if-true (gensym "it")) (result (gensym "r")))
    `(let (,if-true ,result)
       (when-let ,vars
		 (setf ,if-true t
		       ,result ,ifyes))
       (iff ,if-true ,result ,@body))))
#+END_SRC

Usage example:
#+BEGIN_SRC lisp :results drawer
(macroexpand-1 
  '(if-let ((x 1) (y (1+ x)))
     (+ x y) (- x y) (* x y)))
#+END_SRC

#+RESULTS:
:RESULTS:
(LET (#:|it597| #:|r598|)
  (WHEN-LET ((X 1) (Y (1+ X)))
    (SETF #:|it597| T
          #:|r598| (+ X Y)))
  (IFF #:|it597| #:|r598| (- X Y) (* X Y)))
:END:

Sometimes I need slightly changed versions of =if-let=:
#+BEGIN_SRC emacs-lisp :tangle generated/macros.el
(defmacro ifn-let (vars ifno &rest body)
  `(if-let ,vars
      (progn ,@body)
      ,ifno))
#+END_SRC

#+BEGIN_SRC emacs-lisp :results drawer
(print (macroexpand-1 '(ifn-let ((x (+ 1 2))) (+ 3 4) (+ 6 5) (+ 7 9))))
#+END_SRC

#+RESULTS:
:RESULTS:
(if-let ((x (+ 1 2))) (progn (+ 6 5) (+ 7 9)) (+ 3 4))
:END:

#+BEGIN_SRC emacs-lisp
(if-let ((x (+ 1 2))) (progn (+ 6 5) (+ 7 9)) (+ 3 4))
(if-let ((x (+ 1 2))) 1 2)
(if-let ((x t)) 1 2)
#+END_SRC

#+BEGIN_SRC lisp :tangle generated/macros.lisp
(defmacro ifn-let (vars ifno &rest body)
  `(if-let ,vars
      (progn ,@body)
      ,ifno))
#+END_SRC

#+BEGIN_SRC lisp :tangle generated/tests.lisp
(deftest if-let
    (if-let ((x (id :ok)))
            x
            :bad)
  :ok)
(deftest ifn-let
    (ifn-let ((x (id :ok)))
            :bad
x )
  :ok)
#+END_SRC

* needs
(This resembles standard =cl-assert= macro.)
New =needs= macro is gradually replacing =when-let=:
#+BEGIN_SRC emacs-lisp :tangle generated/macros.el
(defmacro needs(vardefs &rest body)
  "unifying when-let and if-let"
  (let ((vardef (car vardefs)))
    (if (and (listp vardef) (not (or (special-form-p (car vardef)) (functionp (car vardef)) (macrop (car vardef)))))
    `(let ((,(car vardef) ,(cadr vardef)))
       ,(if (cddr vardef)
	    `(if ,(car vardef)
		,(if (cdr vardefs)
		     (macroexpand-1 `(needs ,(cdr vardefs) ,@body))
		   `(progn ,@body))
	       ,(car (cddr vardef)))
	  (append `(when ,(car vardef))
		  (if (cdr vardefs)
		      (list (macroexpand-1 `(needs ,(cdr vardefs) ,@body)))
		    body))))
    (append `(when ,vardef)
		  (if (cdr vardefs)
		      (list (macroexpand-1 `(needs ,(cdr vardefs) ,@body)))
		    body)))))
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle generated/tests.el
(ert-deftest needs()
(should(string= "(let ((a (identity 1))) (when a (1+ a)))" (format "%s" (macroexpand-1 `(needs((a (identity 1))) (1+ a))))))
(should(string= "(let ((a (identity 1))) (if a (progn (1+ a)) (alarm)))" (format "%s" (macroexpand-1 `(needs((a (identity 1) (alarm))) (1+ a))))))
(should(= 2 (needs((a (identity 1) 100)) 2)))
(should(= 200 (needs((a (identity 1) 100) (b (identity nil) 200) (c (+ a 1) 300)) 55))))
#+END_SRC

#+BEGIN_SRC lisp :tangle generated/macros.lisp
(defmacro needs(vardefs &rest body)
  "unifying when-let and if-let"
  (let ((vardef (car vardefs)))
    (if (and (listp vardef) (not (functionp (car vardef))))
    `(let ((,(car vardef) ,(cadr vardef)))
       ,(if (cddr vardef)
	    `(if ,(car vardef)
		,(if (cdr vardefs)
		     (macroexpand-1 `(needs ,(cdr vardefs) ,@body))
		   `(progn ,@body))
	       ,(car (cddr vardef)))
	  (append `(when ,(car vardef))
		  (if (cdr vardefs)
		      (list (macroexpand-1 `(needs ,(cdr vardefs) ,@body)))
		    body))))
    (append `(when ,vardef)
		  (if (cdr vardefs)
		      (list (macroexpand-1 `(needs ,(cdr vardefs) ,@body)))
		    body)))))
#+END_SRC

=needs= acts similarly to =when-let= except that for every variable decalared in its header
it has an optional third argument – a form to be evaluated in case the variable turns out to be ~nil~.

#+BEGIN_SRC emacs-lisp :results drawer
(print (macroexpand-1 '(needs
((x (f 1) (message "could not define x"))
 (y (g x) (message "could not define y")))
(message "let's rock")
(- x y))))
#+END_SRC

#+RESULTS:
:RESULTS:
(let ((x (f 1))) (if x (let ((y (g x))) (if y (progn (message let's rock) (- x y)) (message could not define y))) (message could not define x)))
:END:

Formated output:
#+BEGIN_SRC emacs-lisp
(let ((x (f 1)))
  (if x
    (let ((y (g x)))
      (if y
        (progn
	  (message "let's rock")
	  (- x y))
	(message "could not define y")))
    (message could "not define x")))
#+END_SRC


For other usage examples, see [[https://github.com/chalaev/cloud][cloud]] project, e.g.:
#+BEGIN_SRC emacs-lisp :results drawer
(print (macroexpand-1 '(needs ((col-value (begins-with str (car column)) (bad-column "action" (cdr column))))
(aset action (cdr column) (car col-value))
(setf str (cdr col-value)))))
#+END_SRC

Sometimes I need a slightly changed version of =needs= that does not create a local variable,
setting the value of a global one instead:
#+BEGIN_SRC emacs-lisp :tangle generated/macros.el
(defmacro first2(ll) `(firstN ,ll 2))
(defmacro needs-set (vardefs &rest body)
  "needs with 'let' being replaced with 'setf'"
  (let ((vardef (car vardefs)))
    (if (cddr vardef)
      `(if-set (,(first2 vardef))
	  ,(if (cdr vardefs)
	       (macroexpand-1 `(needs-set ,(cdr vardefs) ,@body))
	     `(progn ,@body))
	  ,(caddr vardef))
      `(when-set (,(car vardefs))
	   ,(if (cdr vardefs)
	       (macroexpand-1 `(needs-set ,(cdr vardefs) ,@body))
	      `(progn ,@body))))))
#+END_SRC

Example #1:
#+BEGIN_SRC emacs-lisp :results drawer
(print (macroexpand-1 '(needs-set
((x (f 1) (message "did not set x"))
 (y (g x) (message "did not set y")))
(message "let's rock")
(- x y))))
#+END_SRC

#+RESULTS:
:RESULTS:
(if-set ((x (f 1)))
 (if-set ((y (g x)))
 (progn (message let's rock) (- x y))
 (message did not set y))
 (message did not set x))
:END:

and here is the formatted result:
#+BEGIN_SRC emacs-lisp
(if-set ((x (f 1)))
  (if-set ((y (g x)))
     (progn
       (message let's rock)
       (- x y))
     (message "did not set y"))
  (message "did not set x"))
#+END_SRC

Example #2 (from the [[https://github.com/chalaev/cloud][cloud project]]):
#+BEGIN_SRC emacs-lisp :results drawer
(print (macroexpand-1 '(needs-set
  ((conf (read-conf* (local/config)))
   (remote/files (cdr (assoc "remote/files" conf)) (clog :error "specify 3-symbol contents name (remote/files) in %s" (local/config)))
   (N-CPU-cores (string-to-number
 (or
 (cdr (assoc "number-of-CPU-cores" conf))
 (clog :warning "specify number-of-CPU-cores in %s" (local/config)
 "1"))))
   (password (cdr (assoc "password" conf)) (clog :error "specify password in %s" (local/config)))
   (remote-dir (cdr (assoc "remote-directory" conf)) (clog :error "specify remote-directory in %s" (local/config))))
conf)))
#+END_SRC

#+RESULTS:
:RESULTS:
(when-set ((conf (read-conf* (local/config)))) (if-set ((remote/files (cdr (assoc remote/files conf)))) (when-set ((N-CPU-cores (string-to-number (or (cdr (assoc number-of-CPU-cores conf)) (clog :warning specify number-of-CPU-cores in %s (local/config) 1))))) (if-set ((password (cdr (assoc password conf)))) (if-set ((remote-dir (cdr (assoc remote-directory conf)))) (progn conf) (clog :error specify remote-directory in %s (local/config))) (clog :error specify password in %s (local/config)))) (clog :error specify 3-symbol contents name (remote/files) in %s (local/config))))
:END:
and here is the formatted result:
#+BEGIN_SRC emacs-lisp
(when-set ((conf (read-conf* (local/config))))
  (if-set ((remote/files (cdr (assoc remote/files conf))))
    (when-set ((N-CPU-cores (string-to-number (or (cdr (assoc number-of-CPU-cores conf)) (clog :warning specify number-of-CPU-cores in %s (local/config) 1)))))
      (if-set ((password (cdr (assoc password conf))))
        (if-set ((remote-dir (cdr (assoc remote-directory conf))))
	  (progn conf)
	  (clog :error specify remote-directory in %s (local/config)))
	(clog :error specify password in %s (local/config))))
    (clog :error specify 3-symbol contents name (remote/files) in %s (local/config))))
#+END_SRC

* directory-lock
=(directory-lock locked-dir by body...)= attempts to create directory =locked-dir=.
(Linux kernel is made in such a way, that if several processes are simultaneously trying to create nonexistent directory, *only one* of them succeeds.)

If the directory was sucessfully created,
1. file "by" is created inside it containing the string ~by~, and
2. forms ~body~ are evaluated.

#+BEGIN_SRC emacs-lisp :tangle generated/macros.el
(defmacro directory-lock(locked-dir by &rest body)
(let ((LD (s-gensym "LD")) (lock-file (s-gensym "LF")))
`(let* ((,LD (file-name-as-directory ,locked-dir))
        (,lock-file (concat ,LD "by")))
 (make-directory ,LD t)
 (write-region ,by nil ,lock-file)
(prog1 (progn ,@body)
(delete-file ,lock-file)
(delete-directory ,LD)))))
#+END_SRC

*No matter how many processes are trying to lock the same directory simultaneously, at most one will succeed.*

Example – locking remote directory: 
#+BEGIN_SRC emacs-lisp :results drawer
(print (macroexpand-1 '(directory-lock "/mnt/server/code-name" (system-name)
(body-1) (body-2))))
#+END_SRC

* emacs lisp
** emacs configuration in ~/.emacs
*** "System" emacs functions
#+BEGIN_SRC emacs-lisp :tangle generated/local-packages.el
(unless (functionp 'caddr) (defun caddr(x) (car(cddr x)))); for emacs versions <26
(unless (functionp 'cadar) (defun cadar(x) (car (cdar x))))

(defun emacs-ver()
  (mapcar #'string-to-number (split-string
   (caddr (split-string (emacs-version))) "\\.")))
#+END_SRC

Let us upgrade =upgrade-make-temp-file= on older emacs versions, allowing this novel ~TEXT~ argument:
#+BEGIN_SRC emacs-lisp :tangle generated/local-packages.el
(unless (< 25 (car (emacs-ver)))
  (defun upgrade-make-temp-file(old-function PREFIX &optional DIR-FLAG SUFFIX TEXT)
    (let((FN (funcall old-function PREFIX DIR-FLAG SUFFIX)))
      (when (and TEXT (stringp TEXT))
      (write-region TEXT nil FN))
    FN))
(add-function :around (symbol-function 'make-temp-file) #'upgrade-make-temp-file))
#+END_SRC
← otherwise my =make-temp-file= code *fails* on emacs version 25.1.1 (but works on 26.1).

*** creating PID file
Before launching emacs server in my [[file:.login][~/.login]] file, I check PID file created by
#+BEGIN_SRC emacs-lisp :tangle generated/dot.emacs :shebang ";; -*-  lexical-binding: t; -*-"
;;
;; see https://github.com/chalaev/lisp-goodies/blob/master/packaged/batch-start.el
(load-file "/path-to/batch-start.el")

;; creating PID file for emacs; useful when it gets started from ~/.login
;; see https://github.com/chalaev/lisp-goodies/blob/master/.login
(make-temp-file "emacs-" nil ".pid" (format "%d
" (emacs-pid))); requires version(emacs) > 26
#+END_SRC

*** Placing/Finding local packages
The following 3 blocks allow me to require simple (consisting of one file) locally created packages, for example, this one – =(require 'shalaev)=;

Defining important directories:
#+BEGIN_SRC emacs-lisp :tangle generated/local-packages.el :shebang ";; -*-  lexical-binding: t; -*-"
(defvar HOME (getenv "HOME"))
(defvar ~ (file-name-as-directory HOME))
(defun ~() (file-name-as-directory HOME))
(defun   tilde(x) (replace-regexp-in-string (concat "^" ~) "~/" x))
(defun untilde(x) (replace-regexp-in-string "^~/" ~ x))
(defvar emacs-d (concat "~/" (file-name-as-directory ".emacs.d")))
#+END_SRC

Inform ~emacs~ about new directory =~/.emacs.d/local-packages/= containing package files
(and create it if necessary):
#+BEGIN_SRC emacs-lisp :tangle generated/local-packages.el
(require 'package)
(unless (assoc "local-packages" package-archives)
  (push (cons  "local-packages" (concat emacs-d (file-name-as-directory "local-packages")))
	package-archives))
(make-directory (cdr (assoc "local-packages" package-archives)) t)
#+END_SRC

Adjusting [[https://www.emacswiki.org/emacs/LoadPath][load-path]]:
#+BEGIN_SRC emacs-lisp :tangle generated/local-packages.el
(unless (member (cdr (assoc "local-packages" package-archives)) load-path)
  (add-to-list 'load-path (cdr (assoc "local-packages" package-archives))))
#+END_SRC


*** for using in Makefiles
My [[https://github.com/chalaev/backup2l.conf][backup]] system does not save files having the group ~tmp~.
I use this group to mark all generated (tangled) files:
#+BEGIN_SRC emacs-lisp :tangle generated/make.el
(require 'shalaev) ; ← needed for perms-from-str unless you have loaded it in another way
(defun after-tangle()
  "mark tangled files as non-backupable (chgrp tmp files) and non-excecutable"
  (let ((FN (buffer-file-name)))
#+END_SRC
The following line is equivalent to =chmod a-x FN=:
#+BEGIN_SRC emacs-lisp :tangle generated/make.el
    (set-file-modes FN (logand #o666 (perms-from-str (nth 8 (file-attributes FN 'string)))))
    (chgrp "tmp" FN)))
(add-hook 'org-babel-post-tangle-hook #'after-tangle)
#+END_SRC
so they are not backuped.

My literate programming relies on rmacs or mode and its =M-x org-babel-tangle= command, which I want to output the names of the generated files.
So in [[file:Makefile][Makefiles]] I often use ~printangle~ [it returns the list of exported (tangled) files]:
#+BEGIN_SRC emacs-lisp :tangle generated/make.el
(defun printangle(FN)
  "to be used in Makefile instead of org-babel-tangle-file"
  (let ((l (length default-directory)))
    (apply #'concat (mapcar #'(lambda(x) (substring (format "%s " x) l)) (org-babel-tangle-file FN)))))
#+END_SRC
← my [[https://github.com/chalaev/cl-simple-logger/blob/master/Makefile][Makefile]]s load its definition from [[file:helpers/derive-version.el][derive-version.el]].

*** Other stuff
(found online) =run-init-block=  runs ~init~ code block when loading an org-file:
#+BEGIN_SRC emacs-lisp :tangle generated/make.el
(defun run-init-block ()
"runs code block labeled 'init' when an org-file is opened in emacs"
  (org-babel-goto-named-src-block "init")
  (org-babel-execute-src-block))
#+END_SRC

** replacing cl.el
Just following Stallman's advice, I try to avoid using =cl.el=;
=generated/cl.el= will be my (incomplete for now) replacement for  =cl.el=
to be loaded as follows:
#+BEGIN_SRC emacs-lisp
(unless (functionp 's-gensym)
  (load (concat (file-name-as-directory "generated") "cl.el")))
#+END_SRC

*Problem:* I am not sure if eliminating =cl.el= really makes sence because
apparently it is widely used; for example, =M-x org-babel-tangle= uses =cl.el= (although does not require it).

*** s-gensym
#+BEGIN_SRC emacs-lisp :tangle generated/cl.el :shebang ";; -*-  lexical-binding: t; -*-"
(let ((counter 0))
  (defun s-gensym(&optional starts-with)
    "for those who miss s-gensym from Common Lisp"
    (unless starts-with (setf starts-with "gs"))
    (let (sym)
      (while (progn
               (setf sym (make-symbol (concat starts-with (number-to-string counter))))
               (or (special-form-p sym) (functionp sym) (macrop sym) (boundp sym)))
        (s-incf counter))
      (s-incf counter)
      sym)))
#+END_SRC
=s-gensym= is used in macros, e.g.
#+BEGIN_SRC emacs-lisp :results drawer
(let ((ms (s-gensym "a")))
  `(let ((,ms 0))
     (1+ ,ms)))
#+END_SRC

#+RESULTS:
:RESULTS:
(let ((a3 0)) (1+ a3))
:END:

*** s-find
~s-find~ stands for "shalaev-find"; note that it is *not* compatible with ~find~ from ~cl.el~:
#+BEGIN_SRC emacs-lisp :tangle generated/cl.el
(defun s-find(item seq &optional key test)
  (let ((CS(car seq)) found (test (or test 
(cond
  ((stringp item) #'string=)
  ((numberp item) #'=)
  (t #'eq)))))
  (while
     (and
       (not (setf found (funcall test item (if key (funcall key CS) CS))))
       (setf seq (cdr seq)))
     (setf CS(car seq)))
     (when found CS)))
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle generated/tests.el
(ert-deftest s-find.1()
  (should (equal '(3 4) (s-find 4 '((1 2) (3 4) (5 6)) #'cadr)))
  (should (= 3 (s-find 3 '(1 2 3 4 5))))
(let ((cumbersome-list '(141 142 143 144)))
  (should (= (s-find (* 12 12) cumbersome-list nil #'=) 144))
  (should (= (s-find (/ 144 2) cumbersome-list nil #'(lambda(x y) (= (* 2 x) y))) 144))
  (should (= (s-find 12 cumbersome-list nil #'(lambda(x y) (= (* x x) y))) 144)))
(let ((cumbersome-list '((141 142) (143 144))))
  (should (equal (s-find 12 cumbersome-list #'cadr #'(lambda(x y) (= y (* x x)))) '(143 144)))))
(ert-deftest s-find.2()
"this code comes from cloud project"
(let((plain(lambda(FR)(aref FR 0))) (cipher(lambda(FR)(aref FR 6)))
    (file-DB(list
  ["/home/user/proj/chat/chat.org" "shalaev" "shalaev" (24559 50916 0 0) 48756 420 "U3j"]
  ["~/proj/lisp-goodies/shalaev.org" "shalaev" "shalaev" (24552 57834 0 0) 432 61533 "Q8T"])))
(should(string= "/home/user/proj/chat/chat.org"   (funcall plain (s-find "U3j" file-DB cipher #'string=))))
(should(string= "~/proj/lisp-goodies/shalaev.org" (funcall plain (s-find "Q8T" file-DB cipher #'string=))))))
#+END_SRC

Note the difference from ~find~ defined in ~cl.el~: instead of
#+BEGIN_SRC emacs-lisp
(let ((cumbersome-list '((141 142) (143 144) (145 146))))
  (find 12 cumbersome-list :key #'cadr :test #'(lambda(x y) (= y (* x x)))))
#+END_SRC
we write
#+BEGIN_SRC emacs-lisp
(let ((cumbersome-list '((141 142) (143 144) (145 146))))
  (s-find 12 cumbersome-list #'cadr #'(lambda(x y) (= y (* x x)))))
#+END_SRC

*** s-decf and s-incf
#+BEGIN_SRC emacs-lisp :tangle generated/cl.el
(defmacro s-decf (var &optional amount)
  (unless amount (setf amount 1))
  `(setf ,var (- ,var ,amount)))
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle generated/cl.el
(defmacro s-incf (var &optional amount)
  (unless amount (setf amount 1))
  `(setf ,var (+ ,var ,amount)))
#+END_SRC

*** lett (replacing flet + let)
#+BEGIN_SRC emacs-lisp :tangle generated/cl.el
(defmacro lett(var-defs &rest body)
"let where one can define (usual) local variables as well as local functions"
  (if(car var-defs)
      (let((ME (macroexpand-1 `(lett ,(cdr var-defs) ,@body))))
      (if(and(listp (car var-defs))(eql 'defun (caar var-defs)))
	  (let((func-data (cdar var-defs)))
	    `(let((,(car func-data) (lambda ,(cadr func-data) ,@(cddr func-data))))
	        ,ME))
	`(let(,(car var-defs)) ,ME)))
    `(progn ,@body)))
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle generated/tests.el
(ert-deftest lett()
(should(eval(let((fName(s-gensym)))
`(lett(z (a 2) (defun ,fName(x)(1+ x)) w)
 (functionp ,fName)))))

(should(not(let((fName(s-gensym)))
(functionp fName))))

(let((fName(s-gensym)))
(should(not(or (special-form-p fName) (functionp fName) (macrop fName) (boundp fName)))))

(should (= 6 (lett(z (a 2) (defun sw(x)(1+ x)) w)
  (unless (or z w)
    (setf z (funcall sw a))
    (* z a))))))
#+END_SRC

*** select, without, and drop
#+BEGIN_SRC emacs-lisp :tangle generated/functions.el :shebang ";; -*-  lexical-binding: t; -*-"
(defun select (from-where match-test)
  "select items matching the test"
    (let (collected wasted)
       (dolist (list-item from-where)
	 (if (funcall match-test list-item)
	   (push list-item collected)
	   (push list-item wasted)))
(cons (reverse collected) (reverse wasted))))
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle generated/tests.el
(ert-deftest select()
(let ((test-list  '(4 22 11 33 12 24 77)))
  (should (not (car (select test-list #'zerop))))
  (should (equal '(11 33 77) (car (select test-list #'oddp))))
  (should (equal '(4 22 12 24) (car (select test-list #'evenp))))))
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle generated/functions.el
(defun without(source &rest wrong-items)
  "returns (copy of) source without wrong-items"
  (car (select source #'(lambda(x) (not (member x wrong-items))))))
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle generated/tests.el
(ert-deftest without()
(let ((test-list  '(4 22 11 33 12 24 77)))
  (should (equal '(4 22 11 33 77) (without test-list 12 24)))))
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle generated/macros.el
(defmacro drop (from-where &rest what)
`(setf ,from-where (without ,from-where ,@what)))
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle generated/tests.el
(ert-deftest drop()
(let ((test-list  '(4 22 11 33 12 24 77)))
  (drop test-list 12 24)
  (should (equal '(4 22 11 33 77) test-list))))
#+END_SRC

*** define-vars
The whole point of =define-vars= is to make it easy to switch between ~(let ...)~
and ~(defvar ...)~ so may be later I should redefine it as =(defmacro define-vars (varDefs &rest body)=:
#+BEGIN_SRC emacs-lisp :tangle generated/macros.el
(defmacro define-vars (varDefs)
  "to make switching between local/global variables easier"
(cons 'progn
(mapcar #'(lambda(VD)
  (if (consp VD)
      `(defvar ,@VD)
      `(defvar ,VD nil)))
varDefs)))
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle generated/tests.el
(ert-deftest define-vars()
(should(string= "(progn (defvar a nil) (defvar b nil))" (string-from-macro '(define-vars (a b)))))
(should(string= "(progn (defvar a 1) (defvar b nil) (defvar c 2))" (string-from-macro '(define-vars ((a 1) b (c 2)))))))
#+END_SRC

*** to do
reduce, …

** short pieces of code
*** case*
~case*~ is not identical to =case= from =cl.el=:
it uses arbitrary test function:
#+BEGIN_SRC emacs-lisp :tangle generated/macros.el
(defmacro case* (expr test &rest cases)
  "case with arbitrary test function"
  (let ((v (s-gensym "v")))
    `(let ((,v ,expr))
       (cond
        ,@(mapcar #'(lambda (VR)
(let ((val (car VR)) (rest (cdr VR)))
  (if (eql val 'otherwise)
      `(t ,@rest)
    `((,test ,v ,val) ,@rest))))
 cases)))))
#+END_SRC
A simple example:
#+BEGIN_SRC emacs-lisp :results drawer
(macroexpand-1 
 `(case* (+ 1 2) =
    (choice-1 (message "choice-1"))
    (choice-2 (message "choice-2"))
    (otherwise (message "no match"))))
#+END_SRC

#+RESULTS:
:RESULTS:
(let ((v13 (+ 1 2)))
 (cond 
((= v13 choice-1) (message choice-1))
((= v13 choice-2) (message choice-2))
(t (message no match))))
:END:

Another example is also self-explanatory:
#+BEGIN_SRC emacs-lisp :results drawer
(let ((x 32) (choice-1 22)  (choice-2 33))
  (case* (1+ x) =
    (choice-1 (message "choice-1"))
    (choice-2 (message "choice-2"))
    (otherwise (message "no match"))))
#+END_SRC

#+RESULTS:
:RESULTS:
choice-2
:END:

*** case-let
=case-let= is probably *useless*:
as of 2020-11-04 I think that small convenience due to slight code size reduction does not compensate new symbol introduction, so =case-let= remains unused for now.

Sometimes we may want to access the let-variable name generated in =case*=;
so we define =case-let= which is only a slightly modified version of =case*=:
#+BEGIN_SRC emacs-lisp
(defmacro case-let (let-var expr test &rest cases)
  "case* with let expriable named by the user"
    `(let ((,let-var ,expr))
       (cond
        ,@(mapcar #'(lambda (VR)
(let ((val (car VR)) (rest (cdr VR)))
  (if (eql val 'otherwise)
      `(t ,@rest)
    `((,test ,let-var ,val) ,@rest))))
 cases))))
#+END_SRC
A simple example:
#+BEGIN_SRC emacs-lisp :results drawer
(macroexpand-1 
 `(case-let x (+ 1 2) =
    (choice-1 (format "1: x=%d" x))
    (choice-1 (format "2: x=%d" x))
    (otherwise (message "no match"))))
#+END_SRC

#+RESULTS:
:RESULTS:
(let ((x (+ 1 2))) (cond ((= x choice-1) (format 1: x=%d x)) ((= x choice-1) (format 2: x=%d x)) (t (message no match))))
:END:

*** when-set and unless-set
Sometimes instead of =when-let= I use somewhat similar =when-set= macro.
=when-set= is similar to =when-let= except for that it uses existing global variables instead of creating local ones.

#+begin_note
Global variable values will *not* be set to ~nil~.
#+end_note

#+BEGIN_SRC emacs-lisp :tangle generated/macros.el
(defmacro when-set (vars &rest body)
  "when-let using global variable instead of defining local one"
(let ((GV (s-gensym)))
  `(let ((,GV ,(cadar vars)))
     ,(if (cdr vars)
	  `(when ,GV
              (setf ,(caar vars) ,GV)
	     ,(macroexpand-1 `(when-set ,(cdr vars) ,@body)))
	(append `(when ,GV (setf ,(caar vars) ,GV)) body)))))
#+END_SRC

#+BEGIN_SRC emacs-lisp :results drawer
(print (macroexpand-1
 `(when-set ((CN (clouded (aref newDBrec cipher))) (NFE (not (file-exists-p CN))))
    (+ 1 2)
    (- 1 2))))
#+END_SRC

#+RESULTS:
:RESULTS:
(let ((it15 (clouded (aref newDBrec cipher))))
 (when it15 (setf CN it15) 
   (let ((it16 (not (file-exists-p CN))))
      (when it16 (setf NFE it16) (+ 1 2) (- 1 2)))))
:END:

=unless-set= is similar to =when-set=:
#+BEGIN_SRC emacs-lisp :tangle generated/macros.el
(defmacro unless-set (vars &rest body)
  "unless-let using global variable instead of defining local one"
(let ((GV (s-gensym)))
  `(let ((,GV ,(cadar vars)))
     ,(if (cdr vars)
	  `(if ,GV
              (setf ,(caar vars) ,GV)
	     ,(macroexpand-1 `(unless-set ,(cdr vars) ,@body)))
	(append `(if ,GV (setf ,(caar vars) ,GV)) body)))))
#+END_SRC

#+BEGIN_SRC emacs-lisp :results drawer
(print (macroexpand-1
 `(unless-set ((CN (aref newDBrec cipher)) (FE (file-exists-p CN)))
    (+ 1 2)
    (- 1 2))))
#+END_SRC

#+RESULTS:
:RESULTS:
(let ((g30 (aref newDBrec cipher)))
  (if g30
     (setf CN g30) 
(let ((g31 (file-exists-p CN)))
    (if g31 (setf FE g31)
       (+ 1 2)
       (- 1 2)))))
:END:

*** if-set
#+BEGIN_SRC emacs-lisp :tangle generated/macros.el
(defmacro if-set (vars &rest body)
  (let ((if-true (s-gensym "it")) (result (s-gensym "r")))
    `(let (,if-true ,result)
       (setf ,result (when-set ,vars
		  (setf ,if-true t)
		  ,(car body)))
       (if ,if-true ,result
	 ,@(cdr body)))))
#+END_SRC

#+BEGIN_SRC emacs-lisp :results drawer
(print (macroexpand-1
  '(if-set ((x 1) (y (1+ x)))
     (+ x y) (- x y) (* x y))))
#+END_SRC

#+RESULTS:
:RESULTS:
(let (it28 r29) 
(setf r29 (when-set ((x 1) (y (1+ x))) (setf it28 t) (+ x y)))
 (if it28 r29 (- x y) (* x y)))
:END:

#+BEGIN_SRC emacs-lisp :tangle generated/macros.el
(defmacro ifn-set (vars ifno &rest body)
`(if-set ,vars
   (progn ,@body)
   ,ifno))
#+END_SRC

#+BEGIN_SRC emacs-lisp :results drawer
(print (macroexpand-1 (macroexpand-1 
'(ifn-set
  ((remote/files (cdr (assoc "remote/files" conf)))
   (N-CPU-cores (string-to-number (or (cdr (assoc "number-of-CPU-cores" conf)) "1")))
   (password  (cdr (assoc "password" conf)))
   (remote-dir (cdr (assoc "remote-directory" conf))))
(clog :error "something is missing or wrong in the configuration file" remote-dir)
(print "everything is ok")
(print "so we proceed")))))
#+END_SRC

#+RESULTS:
:RESULTS:
(let (it32 r33) 
  (setf r33
	(when-set ((remote/files (cdr (assoc remote/files conf)))
		   (N-CPU-cores (string-to-number (or (cdr (assoc number-of-CPU-cores conf)) 1)))
		   (password (cdr (assoc password conf)))
		   (remote-dir (cdr (assoc remote-directory conf))))
		  (setf it32 t)
		  (progn (print everything is ok) (print so we proceed))))
  (if it32
      r33
    (clog :error something is missing or wrong in the configuration file remote-dir)))
:END:

*** cond-let
=cond-let= is a natural generalization of =if-let=:
#+BEGIN_SRC emacs-lisp :tangle generated/macros.el
(defmacro cond-let (&rest conds)
  "cond with let"
  (let ((c (car conds)) (r (cdr conds)))
    (if (equal (car c) 'otherwise) `(progn ,@(cdr c))
    (if r
	`(if-let ,(car c) (progn ,@(cdr c)) ,(macroexpand-1 `(cond-let ,@r)))
	`(when-let ,(car c) ,@(cdr c))))))
#+END_SRC

#+BEGIN_SRC emacs-lisp :results drawer
(print (macroexpand-1
  '(cond-let
    (((x 1) (y (1+ x))) (+ x y) (- x y) (* x y))
    (((x 3) (y (1+ x))) (+ x y) (- x y) (/ x y))
    (otherwise 22 33))))
#+END_SRC

#+RESULTS:
:RESULTS:
(if-let ((x 1) (y (1+ x)))
 (progn (+ x y) (- x y) (* x y)) 
(if-let ((x 3) (y (1+ x)))
 (progn (+ x y) (- x y) (/ x y))
 (progn 22 33)))
:END:

Formatted result:
#+BEGIN_SRC emacs-lisp
(if-let ((x 1) (y (1+ x)))
  (progn (+ x y) (- x y) (* x y))
  (if-let ((x 3) (y (1+ x))) 
    (progn (+ x y) (- x y) (/ x y))
    (progn 22 33)))
#+END_SRC

Common Lisp version is the same as elisp one:
#+BEGIN_SRC emacs-lisp :tangle generated/macros.lisp
(defmacro cond-let(&rest conds)
  "cond with let"
  (let ((c (car conds)) (r (cdr conds)))
    (if (equal (car c) 'otherwise) `(progn ,@(cdr c))
    (if r
	`(if-let ,(car c) (progn ,@(cdr c)) ,(macroexpand-1 `(cond-let ,@r)))
	`(when-let ,(car c) ,@(cdr c))))))
#+END_SRC

*** error-in
#+BEGIN_SRC emacs-lisp :tangle generated/macros.el
(defmacro error-in(where &rest body)
"handles unrecognized errors"
`(condition-case err (progn ,@body)
   (error(clog :error (concat "error in " ,where " because
%s") (error-message-string err)))))
#+END_SRC
← to be placed in interactive functions.

Example:
#+BEGIN_SRC emacs-lisp
(error-in "my function" (delete-file "/tmp") t)
#+END_SRC
logs an error message:
:error 13:34:43 error in my function because
Removing old name: is a directory: /tmp

*** email
A non-interactive =email= function:
#+BEGIN_SRC emacs-lisp :tangle generated/functions.el
(defun email (addr &optional subject body)
  "fast non-interactive way to send an email"
  (compose-mail addr (if subject subject ""))
  (when body (insert body))
  (message-send-and-exit))
#+END_SRC
– will work if mailing system (~exim4~ in my case) is configured properly.

*** pos
Position of an element in a list:
#+BEGIN_SRC emacs-lisp :tangle generated/functions.el
(defun pos (el ll)
  (let ((i 0) r)
  (dolist (e ll r)
    (if (eql e el)
	(setf r i)
      (s-incf i)))))
#+END_SRC

*** perms-from-str
When I ask ~emacs~ to show me file's permissions, it provides a text string (e.g., "-rw-rw----") instead of a number.
The following function produces a number from such a string:
#+BEGIN_SRC emacs-lisp :tangle generated/file-functions.el
(require 'cl); hopefully one day I will remove this line
(defun perms-from-str (str)
"parses file mode string into integer"
  (let ((text-mode (reverse (cdr (append str nil)))) (mode 0) (fac 1))
    (loop for c in text-mode for i from 0
          unless (= c ?-) do (s-incf mode fac)
          do (setf fac (* 2 fac)))
    mode))
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle generated/tests.el
(ert-deftest perms-from-str()
  (should (= 432 (perms-from-str "-rw-rw----"))))
#+END_SRC

*** perms-to-str
=perms-to-str= is just the opposite of [[perms-from-str]].

#+BEGIN_SRC emacs-lisp :tangle generated/file-functions.el
(defun perms-to-str(file-mode)
"formats integer file mode into string"
(let ((ll '((1 . 0))))
  (apply #'concat (mapcar
		   #'(lambda(x) (format "%c" (if (= 0 (logand file-mode (car x))) ?- (aref "xwr" (cdr x)))))
  (dotimes (i 8 ll)
     (push (cons (* 2 (caar ll)) (mod (1+ i) 3))  ll))))))
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle generated/tests.el
(ert-deftest perms-to-str()
  (should (string= "rw-rw-rwx" (perms-to-str #o667))))
#+END_SRC

*** time<
In =time<= I have to add 3 seconds of time to avoid chatter effects:
if at some moment the files are synchronized between the host and the cloud,
this situation might change due to time-desynchronization.
#+BEGIN_SRC emacs-lisp :tangle generated/functions.el
(defun time< (t1 t2)
  (and
    (time-less-p (time-add t1 3) t2)
    (not (time-less-p (time-add t2 3) t1))))
#+END_SRC
This problem demonstrates the importance of the time synchronization (via =ntpdate= or an =ntp= server).

*** parsing time and date
#+BEGIN_SRC emacs-lisp :tangle generated/functions.el
(defun parse-date (str)
  (mapcar 'string-to-number
	  (cond
 ((string-match "\\([0-9]\\{4\\}\\)[/-]\\([0-9][0-9]\\)[/-]\\([0-9][0-9]\\)" str) (mapcar #'(lambda (x) (match-string x str)) '(3 2 1)))
 ((string-match "\\([0-9][0-9]\\)[/-]\\([0-9][0-9]\\)[/-]\\([0-9]\\{4\\}\\)" str) (mapcar #'(lambda (x) (match-string x str)) '(2 1 3)))
 ((string-match "\\([0-9][0-9]\\)\\.\\([0-9][0-9]\\)\\.\\([0-9]\\{4\\}\\)" str) (mapcar #'(lambda (x) (match-string x str)) '(1 2 3)))
 ((string-match "\\([0-9][0-9]\\)/\\([0-9][0-9]\\)/\\([0-9]\\{2\\}\\)" str) (mapcar #'(lambda (x) (match-string x str)) '(2 1 3)))
 ((string-match "\\([0-9]\\{2\\}\\)[/-]\\([0-9][0-9]\\)" str) (append (mapcar #'(lambda (x) (match-string x str)) '(2 1)) (list (format-time-string "%Y" (current-time)))))
 (t (clog :error "date format not recognized in %s" str) nil))))
#+END_SRC
#+BEGIN_SRC emacs-lisp :tangle generated/functions.el
(defun parse-only-time (str)
  (firstN (parse-time-string str) 3))
#+END_SRC
#+BEGIN_SRC emacs-lisp :tangle generated/functions.el
(defun parse-date-time(str)
  (if (string-match "[0-9]\\{4\\}-[0-9][0-9]-[0-9][0-9] [0-9][0-9]:[0-9][0-9]" str)
      (parse-time-string str)
    (let ((SS (split-string str)))
      (append (parse-only-time (cadr SS))
	      (parse-date (car SS))))))
#+END_SRC
Example:
#+BEGIN_SRC emacs-lisp :results drawer
(cons (parse-only-time "16:09:37")
(mapcar #'(lambda(x) (format-time-string "%F %H:%M:%S %Z" (apply #'encode-time (parse-date-time x))))
 (list "10/21 14:54"
        "2020-10-10 14:54:40  EDT")))
#+END_SRC

#+RESULTS:
:RESULTS:
((37 9 16) 2020-10-21 14:54:00 EDT 2020-10-10 14:54:40 EDT)
:END:

*** read-conf-file
(12/28 moved here from [[https://github.com/chalaev/cloud][cloud project]], see usage example there.)

Reading configuration file
#+BEGIN_SRC emacs-lisp :tangle generated/macros.el
(defmacro while-let(var-defs while-cond &rest body)
  `(let* (,@var-defs)
     (while ,while-cond
       ,@body)))
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle generated/functions.el
(defun read-conf-file(FN)
  "reads configuration file"
(with-temp-buffer(insert-file-contents FN)
(let (res)
(while-let(str) (< (line-end-position) (point-max))
(setf str (read-line))
  (unless(= ?# (string-to-char str)); ignoring comments
    (if (string-match "^\\(\\ca+\\)=\\(\\ca+\\)$" str)
      (push (cons (match-string 1 str) (match-string 2 str)) res))))
      (reverse res))))
#+END_SRC
produces list of conses.

#+BEGIN_SRC emacs-lisp :tangle generated/functions.el
(defun update-conf(conf &rest conf-params)
  (dolist (CP conf-params)
    (when-let ((CPV (cdr (assoc CP conf)))) (set (intern CP) CPV))))
#+END_SRC


*** simple stuff
#+BEGIN_SRC emacs-lisp :tangle generated/macros.el
(defmacro ifn (test ifnot &rest ifyes)
`(if (not ,test) ,ifnot ,@ifyes))
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle generated/functions.el
(defun firstN(lista N)
  "returning first N elments of the list"
  (when (and (< 0 N) (car lista))
    (cons (car lista) (firstN (cdr lista) (1- N)))))
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle generated/functions.el
(require 'cl)
(defvar *good-chars*
(let ((forbidden-symbols '(?! ?@ ?# ?$ ?% ?& ?* ?\( ?\) ?+ ?= ?/ ?{ ?} ?\[ ?\] ?: ?\; ?< ?> ?_ ?- ?| ?, ?. ?` ?' ?~ ?^ ?\")))
    (append
     (loop for i from ?A to ?Z unless (member i forbidden-symbols) collect i)
     (loop for i from ?a to ?z unless (member i forbidden-symbols) collect i)
     (loop for i from ?0 to ?9 unless (member i forbidden-symbols) collect i)))
"safe characters for file names: everuthing allowed except for what is forbidden")
(defun rand-str(N)
  (apply #'concat
     (loop repeat N collect (string (nth (random (length *good-chars*)) *good-chars*)))))
#+END_SRC

There is probably some standard function or macro doing this:
#+BEGIN_SRC emacs-lisp :tangle generated/macros.el
(defmacro end-push (what where)
"adds an item to the end of the list, resembles 'add-to-list'"
  `(if ,where (push ,what (cdr (last ,where)))
      (push ,what ,where)))
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle generated/tests.el
(ert-deftest end-push()
(should (equal '(1)
(let (container)
  (end-push 1 container)
  container)))
(should (equal '(1 2)
(let (container)
  (end-push 1 container)
  (end-push 2 container)
  container))))
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle generated/functions.el
(defun land(args)
"'and' for a list"
  (reduce #'(lambda(x y) (and x y)) args :initial-value t))
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle generated/tests.el
(ert-deftest land()
  (should (land '(t t t t 1 2)))
  (should (not (land '(t t t nil 1 2)))))
#+END_SRC

12/28 moved here from [[https://github.com/chalaev/cloud][cloud project]]:
#+BEGIN_SRC emacs-lisp :tangle generated/functions.el
(defun sforward-line()
"safe forward-line"
  (if (< (line-end-position) (point-max))
     (forward-line)
     (move-end-of-line 1)))
(defun read-line()
"returns current string of a buffer"
(prog1 
  (buffer-substring-no-properties (line-beginning-position) (line-end-position))
  (sforward-line)))
#+END_SRC

** file/directory fuctions
*** chgrp
#+BEGIN_SRC emacs-lisp :tangle generated/file-functions.el
(defun chgrp(group file-name)
  (= 0 (call-process "chgrp" nil nil nil group file-name)))
#+END_SRC
See also =dired-do-chown=.

*** get-file-properties
This code moved here 12/28 from the [[https://github.com/chalaev/cloud][cloud project]].

BTW, =(file-exists-p FN)= produces ~nil~ if the file resides in directory with (rx) permissions →
#+BEGIN_SRC emacs-lisp :tangle generated/file-functions.el
(defun get-file-properties(FN)
  (when-let ((FA (and (file-exists-p FN) (file-attributes FN 'string))))
      (destructuring-bind
	  (uid gid acess-time mod-time status-time fsize ms void inode fsNum)
	  (cddr FA)
(vector FN uid gid mod-time fsize (perms-from-str ms)))))
#+END_SRC

*** ensure-dir-exists
#+BEGIN_SRC emacs-lisp :tangle generated/file-functions.el
(defun ensure-dir-exists (DN)
(condition-case err
(make-directory DN t)
(file-already-exists (clog :debug "%s already exists" DN)))
DN)
#+END_SRC

*** to-dir
#+BEGIN_SRC emacs-lisp :tangle generated/file-functions.el
(defun to-dir(root &rest dirs)
(if (car dirs)
    (apply #'to-dir
(cons 
  (file-name-as-directory (concat (file-name-as-directory root) (car dirs)))
  (cdr dirs)))
  (file-name-as-directory root)))
#+END_SRC

** logging system
It is probably too small to be packaged.
*** Short description
This code prints log messages to ~*Messages*~ buffer and saves them to log file =~/.emacs.d/elisp.log=.
Every message is formatted similarly to how it is done by =format= function.
*** Code
Global variable =*log-level*= controls how much information should be logged: the (default) zero value means
that all types of log-messages (:debug :warning :info :error) should be logged (saved);
the value 3 means that only error messages (marked with :error) will be logged:
#+BEGIN_SRC emacs-lisp :tangle generated/logging.el
(defvar *log-level* 0)
#+END_SRC
Log messages are accumulated in =*log-buffer*=
#+BEGIN_SRC emacs-lisp :tangle generated/logging.el
(defvar *log-buffer* nil)
#+END_SRC
and once in a while (when the number of queued messages >30 or before quitting ~emacs~) appended to the file =~/.emacs.d/elisp.log=:
#+BEGIN_SRC emacs-lisp :tangle generated/logging.el
(let (last-FLD); saves last day printed to the log file
(defun log-flush()
  "save log messages to file for debugging"
  (when (= 0 *log-level*)
    (with-temp-buffer
      (let ((today-str (format-time-string "%04Y-%02m-%02d" (current-time))))
	(unless (string= today-str last-FLD)
	  (setf last-FLD today-str)
	  (insert today-str) (newline))
	(dolist (msg (reverse *log-buffer*))
	  (insert msg) (newline)))
      (append-to-file (point-min) (point-max) (concat emacs-d "elisp.log")))
    (setf *log-buffer* nil))))
#+END_SRC
The main logging function:
#+BEGIN_SRC emacs-lisp :tangle generated/logging.el
(defun clog(level fstr &rest args)
  "simple logging function" ; level is one of → :debug :info :warning :error
(let ((log-push (lambda(msg)
  (push msg *log-buffer*)
  (when (< 30 (length *log-buffer*)) (log-flush)))))
#+END_SRC
Since we have [[https://www.emacswiki.org/emacs/EmacsLispLimitations][no multi-threading in elisp]], we do not need to introduce any lock functions.
#+BEGIN_SRC emacs-lisp :tangle generated/logging.el
(when (<= *log-level* (or (pos level '(:debug :info :warning :error)) 0))
  (let ((log-msg
	   (cons
	    (concat "%s " (format-time-string "%H:%M:%S "
(apply 'encode-time (butlast (decode-time (current-time)) 3)))
		    fstr)
	    (cons (symbol-name level) args))))
      (funcall log-push (apply #'format log-msg))
      (apply #'message log-msg)))
 nil))
#+END_SRC
where I inserted =nil= at the end just for convenience, since I often use
=clog= for error messages:
#+BEGIN_SRC emacs-lisp
(if (we-got-problems)
(clog :error "we've got %d problems!" 1000)
(the-rest-of-code))
#+END_SRC
← in case of "problems" I want this code block to return =nil=.

Let us not forget to flush the log
#+BEGIN_SRC emacs-lisp :tangle generated/logging.el
(defun on-emacs-exit()
  (clog :debug "flushing comments before quiting emacs")
  (log-flush))
#+END_SRC
before quitting emacs:
#+BEGIN_SRC emacs-lisp :tangle generated/logging.el
(add-hook 'kill-emacs-hook 'on-emacs-exit)
#+END_SRC

** load*
Preventing multiple load of the seame file:
#+BEGIN_SRC emacs-lisp :tangle generated/load.el
(defun barename (FN)
  (let ((SS (split-string (file-name-nondirectory FN)  "\\." t)))
    (mapconcat #'(lambda(x)x) (butlast SS) ".")))
#+END_SRC

The following function is designed to prevent multiple evaluation of one and the same file:
#+BEGIN_SRC emacs-lisp :tangle generated/load.el
(let (loaded); prevents duplicate evaluation of files
(defun load* (x &optional el-prefix)
  (let ((FN (tilde (file-chase-links (concat (or el-prefix "~/") x)))))
    (unless (member (car (last (split-string FN "\\." t))) '("el" "elc"))
      (setf FN (concat FN ".el")))
    (unless (member FN loaded) (load-file FN) (push (barename FN) loaded)))))
#+END_SRC

Usage example:
#+BEGIN_SRC emacs-lisp
(mapcar #'(lambda(x) (load* x "~/programming/"))
	'("macros" "functions" "logging"  ....))
#+END_SRC

* common lisp
** iff
#+BEGIN_SRC lisp :tangle generated/macros.lisp
(defmacro iff (test-form then &rest else)
  "elisp-kind of if"
  (if (cdr else)
      `(if ,test-form ,then (progn ,@else))
      (if (car else)
	  `(if ,test-form ,then ,@else)
	  `(when ,test-form ,then))))
#+END_SRC

#+BEGIN_SRC lisp :results drawer
(macroexpand-1 '(iff 1 2))
#+END_SRC

#+RESULTS:
:RESULTS:
(WHEN 1 2)
T
:END:

#+BEGIN_SRC lisp :results drawer
(macroexpand-1 '(iff 1 2 3))
#+END_SRC

#+RESULTS:
:RESULTS:
(IF 1
    2
    3)
T
:END:

#+BEGIN_SRC lisp :results drawer
(macroexpand-1 '(iff 1 2 3 4))
#+END_SRC

#+RESULTS:
:RESULTS:
(IF 1
    2
    (PROGN 3 4))
T
:END:

** simple stuff
#+BEGIN_SRC lisp :tangle generated/macros.lisp
(defmacro ifn (test ifnot &rest ifyes)
`(iff (not ,test) ,ifnot ,@ifyes))
#+END_SRC

#+BEGIN_SRC lisp :tangle generated/macros.lisp
(defmacro concat (&rest strs)
  `(concatenate 'string ,@strs))
#+END_SRC

#+BEGIN_SRC lisp :tangle generated/tests.lisp
(deftest concat
  (concat "/etc/" "dqoE.tmp")
"/etc/dqoE.tmp")
#+END_SRC

#+BEGIN_SRC lisp :tangle generated/macros.lisp
(defmacro aset(arr pos val)
  `(setf (aref ,arr ,pos) ,val))
#+END_SRC

#+BEGIN_SRC lisp :tangle generated/tests.lisp
(deftest aset
(aref
(let ((container (make-array 5)))
  (aset container 2 23987)
  container)
2)
23987)
#+END_SRC

#+BEGIN_SRC lisp :tangle generated/macros.lisp
(defmacro hset(arr pos val)
  `(setf (gethash ,pos ,arr) ,val))
#+END_SRC

#+BEGIN_SRC lisp :tangle generated/tests.lisp
(deftest hset
(gethash 'one-entry
(let ((container (make-hash-table)))
  (hset container 'one-entry 23987)
  container))
23987 t)
#+END_SRC

** file/directory fuctions
*** rmdir
#+BEGIN_SRC lisp :tangle generated/files.lisp
(defun rmdir(DN)
  (handler-case (cons t (sb-posix:rmdir DN))
    (sb-posix:syscall-error (c)
    (cons nil
      (case (sb-posix:syscall-errno c)
        (13 :permission)
        (2 :absent)
        (39 :occupied)
        (otherwise (cons :unknown (sb-posix:syscall-errno c))))))))
#+END_SRC
– expected to work on SBCL only.

*** echo-to-file
#+BEGIN_SRC lisp :tangle generated/files.lisp
(defun echo-to-file (FN str)
  (with-open-file (stream FN
    :if-exists :overwrite
    :direction :output
    :if-does-not-exist :create)
(format stream "~a~%" str)))
#+END_SRC

*** merge-paths = generalized merge-pathnames
#+BEGIN_SRC lisp :tangle generated/files.lisp
(defun merge-paths(root-dir &rest sub-dirs)
  (reduce
   #'(lambda(DN FN) (merge-pathnames FN (uiop:ensure-directory-pathname DN)))
   sub-dirs
   :initial-value root-dir))
#+END_SRC
