
* emacs configuration

Although I tried to eliminate personal stuff from this section,
still you probably want to adjust this code to your needs before using it:
#+BEGIN_SRC emacs-lisp :tangle generated/dot.emacs :shebang ";;; -*- mode: Emacs-Lisp;  lexical-binding: t; -*-"
;; Generated from https://github.com/chalaev/elisp-goodies/blob/master/goodies.org
;; See explanations therein.
;; Do not forget to edit this file before using it.

(defun basename (FN) (car(last(split-string FN "/" t))))

(defun barename (FN)
  (let ((SS (split-string (basename FN)  "\\." t)))
    (mapconcat #'(lambda(x)x) (butlast SS) ".")))
#+END_SRC

The following function is designed to prevent multiple evaluation of one and the same file:
#+BEGIN_SRC emacs-lisp :tangle generated/dot.emacs
(defvar *loaded* nil "prevents duplicate evaluation of files")
(defun load-file* (x &optional el-prefix)
  (let ((FN (file-chase-links 
             (if (= ?/ (aref x 0)) x
               (concat (or el-prefix 
 (concat (getenv "HOME") "/"))
x)))))
    (unless (member (car (last (split-string FN "\\." t))) '("el" "elc"))
      (setf FN (concat FN ".el")))
    (unless (member FN *loaded*) (load-file FN) (push (barename FN) *loaded*))))
#+END_SRC
Every time I start emacs, I load several files:
#+BEGIN_SRC emacs-lisp :tangle generated/dot.emacs
(mapcar #'(lambda(x) (load-file* x "~/programming/emacs/"))
	'("macros" "functions" "logging"  ....))
#+END_SRC
where dots stand for some other files I use to make my emacs cozy.

My ~backup~ system does not save files having the group ~tmp~.
I use this group to mark all generated (tangled) files:
#+BEGIN_SRC emacs-lisp :tangle generated/dot.emacs
(defun after-tangle()
  "tangled files are temporary, should not be backuped"
  (let ((FN (buffer-file-name)))
#+END_SRC
The following line is equivalent to =chmod a-x FN=:
#+BEGIN_SRC emacs-lisp :tangle generated/dot.emacs
    (set-file-modes FN (logand #o666 (perms-from-str (nth 8 (file-attributes FN 'string)))))
    (chgrp "tmp" FN)))
(add-hook 'org-babel-post-tangle-hook #'after-tangle)
#+END_SRC
so they are not backuped.


* short pieces of code
** chgrp
#+BEGIN_SRC emacs-lisp :tangle generated/functions.el :shebang ";;; -*- mode: Emacs-Lisp;  lexical-binding: t; -*-"
;; generated from https://github.com/chalaev/elisp-goodies/blob/master/goodies.org
(defun chgrp(group file-name)
  (let (process (counter 300) (buffer (generate-new-buffer " *chgrp*")))
    (setf process (apply #'start-process "cloud-chgrp" buffer "chgrp" (list group file-name)))
    (while (and (> counter 0) (eq (process-status process) 'run))
      (decf counter) (sleep-for 0.1))))
#+END_SRC
– I should probably get rid of =sleep-for= here.

** gensym
Actually =gensym= is defined in =cl.el= but I prefer to avoid using it; so let me write my own =gensym=:
#+BEGIN_SRC emacs-lisp :tangle generated/functions.el
(unless (functionp 'gensym)
(let ((counter 0))
  (defun gensym(&optional starts-with)
    "for those who miss gensym from Common Lisp"
    (unless starts-with (setf starts-with "gs"))
    (let (sym)
      (while (progn
               (setf sym (make-symbol (concat starts-with (number-to-string counter))))
               (or (special-form-p sym) (functionp sym) (macrop sym) (boundp sym)))
        (incf counter))
      (incf counter)
      sym))))
#+END_SRC
I use =gensym= in macros, e.g.
#+BEGIN_SRC emacs-lisp :results drawer
(let ((ms (gensym "a")))
  `(let ((,ms 0))
     (1+ ,ms)))
#+END_SRC

#+RESULTS:
:RESULTS:
(let ((a3 0)) (1+ a3))
:END:

** case=
My ~case=~ is not exactly the same as =case= defined in =cl.el=:
it uses integer equality (=) as a test function:
#+BEGIN_SRC emacs-lisp :tangle generated/macros.el :shebang ";;; -*- mode: Emacs-Lisp;  lexical-binding: t; -*-"
;; generated from https://github.com/chalaev/elisp-goodies/blob/master/goodies.org
(defmacro case= (var &rest cases)
  "case with integer equality (=) as a test function"
  (let ((v (gensym "v")))
    `(let ((,v ,var))
       (cond
        ,@(mapcar #'(lambda (VR)
(let ((val (car VR)) (rest (cdr VR)))
  (if (eql val 'otherwise)
      `(t ,@rest)
    `((= ,v ,val) ,@rest))))
 cases)))))
#+END_SRC
A simple example:
#+BEGIN_SRC emacs-lisp :results drawer
(macroexpand-1 
 `(case= (+ 1 2)
	 (choice-1 (message "choice-1"))
	 (choice-2 (message "choice-2"))
	 (otherwise (message "no match"))))
#+END_SRC

#+RESULTS:
:RESULTS:
(let ((v24 (+ 1 2))) (cond ((= v24 choice-1) (message choice-1)) ((= v24 choice-2) (message choice-2)) (t (message no match))))
:END:
where quotes somehow disappeared: is this an ~org-mode~ or ~babel~ bug?

A simple usage example is self-explanatory:
#+BEGIN_SRC emacs-lisp :tangle generated/examples.el
(let ((x 33) (choice-1 22)  (choice-2 33))
  (case= (1+ x)
	 (choice-1 (message "choice-1"))
	 (choice-2 (message "choice-2"))
	 (otherwise (message "no match"))))
#+END_SRC

** when-let
=when-let= is one of my most-used macros:
#+BEGIN_SRC emacs-lisp :tangle generated/macros.el
(defmacro when-let (vars &rest body)
  "when with let using stndard let-notation"
  (if (caar vars)
  `(let ((,(caar vars) ,(cadar vars)))
     ,(if (cdr vars)
	  `(when ,(caar vars)
	     ,(macroexpand-1 `(when-let ,(cdr vars) ,@body)))
	(append `(when ,(caar vars)) body)))
  (if (cdr vars)
      `(when ,(cadar vars)
	     ,(macroexpand-1 `(when-let ,(cdr vars) ,@body)))
    (append `(when ,(cadar vars)) body))))
#+END_SRC
Using standard let-syntax, it evaluates varibales in the header one after another,
and, if they are all non-nil, evalueates the body:
#+BEGIN_SRC emacs-lisp :results drawer
(print (macroexpand-1 
  '(when-let ((x 1) (y (1+ x)))
       (incf x y) (incf y x))))
#+END_SRC

#+RESULTS:
:RESULTS:
(let ((x 1)) (when x (let ((y (1+ x))) (when y (incf x y) (incf y x)))))
:END:

If we put =nil= instead of the variable name, no local varibale will be created for this entry
#+BEGIN_SRC emacs-lisp :results drawer
(print (macroexpand-1
 `(when-let ((CN (clouded (aref newDBrec cipher))) (nil (not (file-exists-p CN))))
    (+ 1 2)
    (- 1 2))))
#+END_SRC

#+RESULTS:
:RESULTS:
(let ((CN (clouded (aref newDBrec cipher)))) (when CN (when (not (file-exists-p CN)) (+ 1 2) (- 1 2))))
:END:
– this double =when= is ugly and inefficient, but for ~elisp~ it is probably o.k. because we do not need as much efficiency here, as in Common Lisp.

Sometimes I use somewhat similar =when-set= macro:
#+BEGIN_SRC emacs-lisp :tangle generated/macros.el
(defmacro when-set (vars &rest body)
  "when-let using global variable instead of defining local one"
  `(progn (setf ,(caar vars) ,(cadar vars)); get rid of progn here
     ,(if (cdr vars)
	  `(when ,(caar vars)
	     ,(macroexpand-1 `(when-set ,(cdr vars) ,@body)))
	(append `(when ,(caar vars)) body))))
#+END_SRC

Recently I wrote =needs= (see below) which is now gradually replacing =when-let=.

** if-let
Like =when-let=, macro =if-let= is heavily used in my projects.
=if-let= is somewhat similar to =when-let=, but offers "else" clause:
#+BEGIN_SRC emacs-lisp :tangle generated/macros.el
(defmacro if-let (vars &rest body)
  "if with let using stndard let-notation"
  (let ((if-true (gensym "it")) (result (gensym "r")))
    `(let (,if-true ,result)
       (when-let ,vars
		 (setf ,if-true t)
		 (setf ,result ,(car body)))
       (if ,if-true
	   ,result
	 ,@(cdr body)))))
#+END_SRC
Usage example:
#+BEGIN_SRC emacs-lisp :results drawer
(print (macroexpand-1 
  '(if-let ((x 1) (y (1+ x)))
     (+ x y) (- x y) (* x y))))
#+END_SRC

#+RESULTS:
:RESULTS:
(let (it27) (when-let ((x 1) (y (1+ x))) (setf it27 t) (+ x y)) (unless it27 (- x y) (* x y)))
:END:

Sometimes I need slightly changed versions of =if-let=:
#+BEGIN_SRC emacs-lisp :tangle generated/macros.el
(defmacro ifn-let (vars &rest body)
  `(if-let ,vars
      ,(cons 'progn (cdr body))
    ,(car body)))
#+END_SRC
#+BEGIN_SRC emacs-lisp :tangle generated/macros.el
(defmacro ifn-set (vars &rest body)
  `(if-set ,vars
      ,(cons 'progn (cdr body))
    ,(car body)))
#+END_SRC
*Warning*: =if-set= should probably
be updated by introducing =result= variable similarly to how it is done
in =if-let= above:
#+BEGIN_SRC emacs-lisp :tangle generated/macros.el
(defmacro if-set (vars &rest body)
  (let ((if-true (gensym "it")))
    `(let (,if-true)
       (when-set ,vars
		  (setf ,if-true t)
		  ,(car body))
       (unless ,if-true
	 ,@(cdr body)))))
#+END_SRC

** cond-let
=cond-let= is a natural generalization of =if-let=:
#+BEGIN_SRC emacs-lisp :tangle generated/macros.el
(defmacro cond-let (&rest conds)
  "cond with let"
  (let ((c (car conds)) (r (cdr conds)))
    (if (equal (car c) 'otherwise) (cons 'progn (cdr c))
    (if r
	`(if-let ,(car c) ,(cons 'progn (cdr c)) ,(macroexpand-1 `(cond-let ,@r)))
	`(when-let ,(car c) ,@(cdr c))))))
#+END_SRC

#+BEGIN_SRC emacs-lisp :results drawer
(print (macroexpand-1
  '(cond-let
    (((x 1) (y (1+ x))) (+ x y) (- x y) (* x y))
    (((x 3) (y (1+ x))) (+ x y) (- x y) (/ x y))
    (otherwise 22 33))))
#+END_SRC

#+RESULTS:
:RESULTS:
(if-let ((x 1) (y (1+ x))) (progn (+ x y) (- x y) (* x y)) (if-let ((x 3) (y (1+ x))) (progn (+ x y) (- x y) (/ x y)) (progn 22 33)))
:END:

** needs
New =needs= macro is gradually replacing =when-let=:
#+BEGIN_SRC emacs-lisp :tangle generated/macros.el
(defmacro needs (&rest all-args)
  "unifying when-let and if-let"
  (let* ((vardefs (car all-args))
	(body (cdr all-args))
	(vardef (car vardefs)))
    (if (and (listp vardef) (not (or (special-form-p (car vardef)) (functionp (car vardef)) (macrop (car vardef)))))
    `(let ((,(car vardef) ,(cadr vardef)))
       ,(if (cddr vardef)
	    `(if ,(car vardef)
		,(if (cdr vardefs)
		     (macroexpand-1 `(needs ,(cdr vardefs) ,@body))
		   `(progn ,@body))
	       ,(car (cddr vardef)))
	  (append `(when ,(car vardef))
		  (if (cdr vardefs)
		      (list (macroexpand-1 `(needs ,(cdr vardefs) ,@body)))
		    body))))
    (append `(when ,vardef)
		  (if (cdr vardefs)
		      (list (macroexpand-1 `(needs ,(cdr vardefs) ,@body)))
		    body)))))
#+END_SRC
=needs= acts very similarly to =when-let= except that for every variable decalared in its header
it has an optional third argument – a form to be evaluated in case the variable turns out to be ~nil~.

For usage example, see [[https://github.com/chalaev/cloud][cloud]] project.

Sometimes I need slightly changed versions of =needs=:
#+BEGIN_SRC emacs-lisp :tangle generated/macros.el
(defmacro needs-set (&rest all-args)
  "needs with 'let' being replaced with 'setf'"
  (let* ((vardefs (car all-args))
	(body (cdr all-args))
	(vardef (car vardefs)))
    (if (and (listp vardef) (not (or (special-form-p (car vardef)) (functionp (car vardef)) (macrop (car vardef)))))
    `(progn (setf ,(car vardef) ,(cadr vardef))
       ,(if (cddr vardef)
	    `(if ,(car vardef)
		,(if (cdr vardefs)
		     (macroexpand-1 `(needs ,(cdr vardefs) ,@body))
		   `(progn ,@body))
	       ,(car (cddr vardef)))
	  (append `(when ,(car vardef))
		  (if (cdr vardefs)
		      (list (macroexpand-1 `(needs ,(cdr vardefs) ,@body)))
		    body))))
    (append `(when ,vardef)
		  (if (cdr vardefs)
		      (list (macroexpand-1 `(needs ,(cdr vardefs) ,@body)))
		    body)))))
#+END_SRC

** email
Sometimes I need to =email=:
#+BEGIN_SRC emacs-lisp :tangle generated/functions.el
(defun email (addr &optional subject body)
  "fast non-interactive way to send an email"
  (compose-mail addr (if subject subject ""))
  (when body (insert body))
  (message-send-and-exit))
#+END_SRC

** remo & drop
#+BEGIN_SRC emacs-lisp :tangle generated/functions.el
(defun remo (from-where &rest what)
  (if (cdr what)
      (remo
       (apply #'remo (cons from-where (cdr what)))
       (car what))
 (remove (car what) from-where)))
(defmacro drop (from-where &rest what)
  `(setf ,from-where (remo ,from-where ,@what)))
#+END_SRC
Test:
#+BEGIN_SRC emacs-lisp :results drawer
(let ((ll '(1 2 3 4 5 6)))
  (drop ll 2 4)
  ll)
#+END_SRC

#+RESULTS:
:RESULTS:
(1 3 5 6)
:END:

** perms-from-str
When I ask ~emacs~ to show me file's permissions, it provides a text string (e.g., "-rw-rw----") instead of a number.
The following function produces a number from such a string:
#+BEGIN_SRC emacs-lisp :tangle generated/functions.el
(defun perms-from-str (str)
"parses file mode string into integer"
  (let ((text-mode (reverse (cdr (append str nil)))) (mode 0) (fac 1))
    (loop for c in text-mode for i from 0
          unless (= c ?-) do (incf mode fac)
          do (setf fac (* 2 fac)))
    mode))
#+END_SRC
Usage example:
#+BEGIN_SRC emacs-lisp :results drawer
(perms-from-str "-rw-rw----")
#+END_SRC

#+RESULTS:
:RESULTS:
432
:END:

** perms-to-str
=perms-to-str= is just the opposite of [[perms-from-str]].
#+BEGIN_SRC emacs-lisp :results drawer
(let ((ll '((1 . 0))))
  (dotimes (i 8 ll)
     (push (cons (* 2 (caar ll)) (mod (1+ i) 3))  ll)))
#+END_SRC

#+RESULTS:
:RESULTS:
((256 . 2) (128 . 1) (64 . 0) (32 . 2) (16 . 1) (8 . 0) (4 . 2) (2 . 1) (1 . 0))
:END:

#+BEGIN_SRC emacs-lisp :results drawer
(let ((ll '((1 . 0))))
  (dotimes (i 8 ll)
     (push (cons (* 2 (caar ll)) (mod (1+ i) 3))  ll)))
#+END_SRC

#+RESULTS:
:RESULTS:
((256 . 2) (128 . 1) (64 . 0) (32 . 2) (16 . 1) (8 . 0) (4 . 2) (2 . 1) (1 . 0))
:END:

#+BEGIN_SRC emacs-lisp :results drawer
(let ((ll '((1 . 0))) (file-mode #o664))
  (apply #'concat (mapcar
		   #'(lambda(x) (format "%c" (if (= 0 (logand file-mode (car x))) ?- (aref "xwr" (cdr x)))))
  (dotimes (i 8 ll)
     (push (cons (* 2 (caar ll)) (mod (1+ i) 3))  ll)))))
#+END_SRC

#+RESULTS:
:RESULTS:
rw-rw-r--
:END:
#+BEGIN_SRC emacs-lisp :tangle generated/functions.el
(defun perms-to-str(file-mode)
"formats integer file mode into string"
(let ((ll '((1 . 0))))
  (apply #'concat (mapcar
		   #'(lambda(x) (format "%c" (if (= 0 (logand file-mode (car x))) ?- (aref "xwr" (cdr x)))))
  (dotimes (i 8 ll)
     (push (cons (* 2 (caar ll)) (mod (1+ i) 3))  ll))))))
#+END_SRC
Usage example:
#+BEGIN_SRC emacs-lisp :results drawer
(perms-to-str #o667)
#+END_SRC

#+RESULTS:
:RESULTS:
rw-rw-rwx
:END:

** simple stuff

#+BEGIN_SRC emacs-lisp :tangle generated/macros.el
(defmacro ifn (test ifnot &rest ifyes)
`(if (not ,test) ,ifnot ,@ifyes))
#+END_SRC
=decf= and =incf= are defined in ~cl.el~ so let us not redefine them if ~cl.el~ is loaded:
#+BEGIN_SRC emacs-lisp :tangle generated/functions.el
(unless (or (boundp 'decf) (functionp 'decf) (macrop 'decf))
(defmacro decf (var &optional amount)
  (unless amount (setf amount 1))
  `(setf ,var (- ,var ,amount))))
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle generated/functions.el
(unless (or (boundp 'incf) (functionp 'incf) (macrop 'incf))
(defmacro incf (var &optional amount)
  (unless amount (setf amount 1))
  `(setf ,var (+ ,var ,amount))))
#+END_SRC
Position of an element in a list:
#+BEGIN_SRC emacs-lisp :tangle generated/functions.el
(defun pos (el ll)
  (let ((i 0) r)
  (dolist (e ll r)
    (if (eql e el)
	(setf r i)
      (incf i)))))
#+END_SRC

* logging system
I doubt if I should really package my logging system: probably it is not large enough.
** Short description
This code prints log messages to ~*Messages*~ buffer and saves them to log file =~/.emacs.d/elisp.log=.
Every message is formatted similarly to how it is done in =format= function.
** Code
Global variable =*log-level*= controls how much information should be logged: the (default) zero value means
that all types of log-messages (:debug :warning :info :error) should be logged (saved);
the value 3 means that only error messages (marked with :error) will be logged:
#+BEGIN_SRC emacs-lisp :tangle generated/logging.el :shebang ";;; -*- mode: Emacs-Lisp;  lexical-binding: t; -*-"
;; generated from https://github.com/chalaev/elisp-goodies/blob/master/goodies.org
(unless (boundp '*log-level*) (defvar *log-level* 0))
(unless (boundp '*emacs-d*) (defvar *emacs-d* (concat (getenv "HOME") "/.emacs.d/")))
#+END_SRC
Log messages are accumulated in =*file-acc-buffer*=
#+BEGIN_SRC emacs-lisp :tangle generated/logging.el
(unless (boundp '*file-acc-buffer*) (defvar *file-acc-buffer* nil))
(defvar *last-FLD* nil "saves last day printed to the log file")
#+END_SRC
and once in a while (when the number of queued messages >30 or before quitting ~emacs~) appended to the file =~/.emacs.d/elisp.log=:
#+BEGIN_SRC emacs-lisp :tangle generated/logging.el
(defun clog-flush()
  "save log messages to file for debugging"
  (when (= 0 *log-level*)
    (with-temp-buffer
      (let ((today-str (format-time-string "%04Y-%02m-%02d" (current-time))))
	(unless (string= today-str *last-FLD*)
	  (setf *last-FLD* today-str)
	  (insert today-str) (newline))
	(dolist (msg (reverse *file-acc-buffer*))
	  (insert msg) (newline)))
      (append-to-file (point-min) (point-max) (concat *emacs-d* "elisp.log")))
    (setf *file-acc-buffer* nil)))
#+END_SRC
Since we have no multi-threading in elisp, we do not need to introduce any lock functions.
#+BEGIN_SRC emacs-lisp :tangle generated/logging.el
(defun file-acc-push(msg)
  (when (= 0 *log-level*)
    (push msg *file-acc-buffer*)
    (when (< 30 (length *file-acc-buffer*)) (clog-flush))))
#+END_SRC
The main logging function:
#+BEGIN_SRC emacs-lisp :tangle generated/logging.el
(defun clog (level fstr &rest args)
  "simple logging function" ; level is one of → :debug :info :warning :error
  (when (<= *log-level* (or (pos level '(:debug :info :warning :error)) 0))
    (let ((log-msg
	   (cons
	    (concat "%s " (format-time-string "%H:%M:%S "
(apply 'encode-time (butlast (decode-time (current-time)) 3)))
		    fstr)
	    (cons (symbol-name level) args))))
      (file-acc-push (apply #'format log-msg))
      (apply #'message log-msg))))
#+END_SRC
Its typical usage example is: =(clog :info "z=%d" 3)=

Let us not forget to flush the log
#+BEGIN_SRC emacs-lisp :tangle generated/logging.el
(defun on-emacs-exit()
  (clog :debug "flushing comments before quiting emacs")
  (clog-flush))
#+END_SRC
before quitting emacs:
#+BEGIN_SRC emacs-lisp :tangle generated/logging.el
(add-hook 'kill-emacs-hook 'on-emacs-exit)
#+END_SRC
* to do
1. Package the logging system?
2. The rest of this project does not deserve packaging sice it is too much focused on my writing style;
   However, I can and must write the code allowing easy usage (by downloading) this project without packaging it.
