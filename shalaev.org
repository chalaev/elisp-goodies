;; -*- eval: (run-init-block); -*-
#+TITLE: useful lisp macros and functions
#+AUTHOR: Oleg Shalaev
#+EMAIL:  oleg@chalaev.com
#+LaTeX_HEADER: \usepackage[russian,english]{babel}
#+LATEX_HEADER: \usepackage[letterpaper,hmargin={1.5cm,1.5cm},vmargin={1.3cm,2cm},nohead,nofoot]{geometry}
#+KEYWORDS: emacs, elisp, common lisp, macros, functions

* Introduction
The following block is evaluated when this ~.org~ file is loaded:
#+NAME: init
#+BEGIN_SRC emacs-lisp :results output none
(defun cons-to-list(co)
"transforms cons to list"
(if (consp co)
  (cons (car co) (cons-to-list (cdr co)))
  (list co)))
#+END_SRC

Notes:
1. Evaluation results are important part of this file, but =github= org-parser does not show them.
   (BTW [[https://notabug.org/shalaev/lisp-goodies/src/master/goodies.org][notabug does show them]] although unformatted.)  Consider opening this file in ~emacs~ instead of watching it online.
2. Sometimes a demonstration of a function might use the definition of another function defined below in this file or another
   file from the ~generated/~ directory, so you might need to =load= those first. And here comes the first example :)
   using =randstr= function defined in [[file:generated/functions.el][generated/functions.el]]:

#+NAME: randstr
#+BEGIN_SRC emacs-lisp
(concat (rand-str 4) ".tmp")
#+END_SRC

* when-let
=when-let= is one of my most-used macros:
#+BEGIN_SRC emacs-lisp :tangle generated/macros.el
(defmacro when-let (vars &rest body)
  "when with let using standard let-notation"
  (if (caar vars)
  `(let ((,(caar vars) ,(cadar vars)))
     ,(if (cdr vars)
	  `(when ,(caar vars)
	     ,(macroexpand-1 `(when-let ,(cdr vars) ,@body)))
	(append `(when ,(caar vars)) body)))
  (if (cdr vars)
      `(when ,(cadar vars)
	     ,(macroexpand-1 `(when-let ,(cdr vars) ,@body)))
    (append `(when ,(cadar vars)) body))))
#+END_SRC

Using standard let-syntax, it evaluates varibales in the header one after another,
and, if they are all non-nil, evalueates the body:
#+BEGIN_SRC emacs-lisp :results drawer
(print (macroexpand-1 
  '(when-let ((x 1) (y (1+ x)))
       (incf x y) (incf y x))))
#+END_SRC

#+RESULTS:
:RESULTS:
(let ((x 1)) (when x (let ((y (1+ x))) (when y (incf x y) (incf y x)))))
:END:

=when-let= defined here has almost the same functionality, as [[https://common-lisp.net/project/alexandria/draft/alexandria.html][alexandria:when-let*]].
If we put =nil= instead of the variable name, no local varibale will be created for this entry:
#+BEGIN_SRC emacs-lisp :results drawer
(print (macroexpand-1
 `(when-let ((CN (clouded (aref newDBrec cipher))) (nil (not (file-exists-p CN))))
    (+ 1 2)
    (- 1 2))))
#+END_SRC

#+RESULTS:
:RESULTS:
(let ((CN (clouded (aref newDBrec cipher)))) (when CN (when (not (file-exists-p CN)) (+ 1 2) (- 1 2))))
:END:
– this double =when= is ugly and inefficient, but for ~elisp~ it is probably o.k. because we do not need as much efficiency here, as in Common Lisp.

Later I wrote [[needs]] which is more general than =when-let=, and can replace it.

CL code is the same:
#+BEGIN_SRC lisp :tangle generated/macros.lisp
(defmacro when-let (vars &rest body)
  "when with let using standard let-notation"
  (if (caar vars)
  `(let ((,(caar vars) ,(cadar vars)))
     ,(if (cdr vars)
	  `(when ,(caar vars)
	     ,(macroexpand-1 `(when-let ,(cdr vars) ,@body)))
	(append `(when ,(caar vars)) body)))
  (if (cdr vars)
      `(when ,(cadar vars)
	     ,(macroexpand-1 `(when-let ,(cdr vars) ,@body)))
    (append `(when ,(cadar vars)) body))))
#+END_SRC

#+BEGIN_SRC lisp :tangle generated/tests.lisp
(deftest when-let.1
    (when-let ((x (id :ok)))
      (setf x (cons x x))
      x)
  (:ok . :ok))
#+END_SRC

* if-let
Like =when-let=, macro =if-let= is heavily used in my projects.
It is somewhat similar to =when-let=, but offers "else" clause:
#+BEGIN_SRC emacs-lisp :tangle generated/macros.el
(defmacro if-let (vars ifyes &rest body)
  "if with let using standard let-notation"
  (let ((if-true (gensym "it")) (result (gensym "r")))
    `(let (,if-true ,result)
       (when-let ,vars
		 (setf ,if-true t
		  ,result ,ifyes))
       (if ,if-true
	   ,result
	 ,@body))))
#+END_SRC
It has almost the same functionality, as [[https://common-lisp.net/project/alexandria/draft/alexandria.html][alexandria:if-let]]
except that instead of single =else-form= there can be multiple forms.

Usage example:
#+BEGIN_SRC emacs-lisp :results drawer
(print (macroexpand-1 
  '(if-let ((x 1) (y (1+ x)))
     (+ x y) (- x y) (* x y))))
#+END_SRC

#+RESULTS:
:RESULTS:
(let (it40 r41) (when-let ((x 1) (y (1+ x))) (setf it40 t r41 (+ x y))) (if it40 r41 (- x y) (* x y)))
:END:

#+BEGIN_SRC emacs-lisp
(let (it40 r41) 
(when-let ((x 1) (y (1+ x))) 
  (setf it40 t
         r41 (+ x y)))
(if it40 r41
   (- x y) (* x y)))
#+END_SRC

#+BEGIN_SRC lisp :tangle generated/macros.lisp
(defmacro if-let (vars ifyes &rest body)
  "if with let using standard let-notation"
  (let ((if-true (gensym "it")) (result (gensym "r")))
    `(let (,if-true ,result)
       (when-let ,vars
		 (setf ,if-true t
		       ,result ,ifyes))
       (iff ,if-true ,result ,@body))))
#+END_SRC

Usage example:
#+BEGIN_SRC lisp :results drawer
(macroexpand-1 
  '(if-let ((x 1) (y (1+ x)))
     (+ x y) (- x y) (* x y)))
#+END_SRC

#+RESULTS:
:RESULTS:
(LET (#:|it597| #:|r598|)
  (WHEN-LET ((X 1) (Y (1+ X)))
    (SETF #:|it597| T
          #:|r598| (+ X Y)))
  (IFF #:|it597| #:|r598| (- X Y) (* X Y)))
:END:

Sometimes I need slightly changed versions of =if-let=:
#+BEGIN_SRC emacs-lisp :tangle generated/macros.el
(defmacro ifn-let (vars ifno &rest body)
  `(if-let ,vars
      (progn ,@body)
      ,ifno))
#+END_SRC

#+BEGIN_SRC emacs-lisp :results drawer
(print (macroexpand-1 '(ifn-let ((x (+ 1 2))) (+ 3 4) (+ 6 5) (+ 7 9))))
#+END_SRC

#+RESULTS:
:RESULTS:
(if-let ((x (+ 1 2)))
 (progn (+ 6 5) (+ 7 9))
 (+ 3 4))
:END:

#+BEGIN_SRC lisp :tangle generated/macros.lisp
(defmacro ifn-let (vars ifno &rest body)
  `(if-let ,vars
      (progn ,@body)
      ,ifno))
#+END_SRC

#+BEGIN_SRC lisp :tangle generated/tests.lisp
(deftest if-let.1
    (if-let ((x (id :ok)))
            x
            :bad)
  :ok)
#+END_SRC

* needs
New =needs= macro is gradually replacing =when-let=:
#+BEGIN_SRC emacs-lisp :tangle generated/macros.el
(defmacro needs (vardefs &rest body)
  "unifying when-let and if-let"
  (let ((vardef (car vardefs)))
    (if (and (listp vardef) (not (or (special-form-p (car vardef)) (functionp (car vardef)) (macrop (car vardef)))))
    `(let ((,(car vardef) ,(cadr vardef)))
       ,(if (cddr vardef)
	    `(if ,(car vardef)
		,(if (cdr vardefs)
		     (macroexpand-1 `(needs ,(cdr vardefs) ,@body))
		   `(progn ,@body))
	       ,(car (cddr vardef)))
	  (append `(when ,(car vardef))
		  (if (cdr vardefs)
		      (list (macroexpand-1 `(needs ,(cdr vardefs) ,@body)))
		    body))))
    (append `(when ,vardef)
		  (if (cdr vardefs)
		      (list (macroexpand-1 `(needs ,(cdr vardefs) ,@body)))
		    body)))))
#+END_SRC

#+BEGIN_SRC lisp :tangle generated/macros.lisp
(defmacro needs(vardefs &rest body)
  "unifying when-let and if-let"
  (let ((vardef (car vardefs)))
    (if (and (listp vardef) (not (functionp (car vardef))))
    `(let ((,(car vardef) ,(cadr vardef)))
       ,(if (cddr vardef)
	    `(if ,(car vardef)
		,(if (cdr vardefs)
		     (macroexpand-1 `(needs ,(cdr vardefs) ,@body))
		   `(progn ,@body))
	       ,(car (cddr vardef)))
	  (append `(when ,(car vardef))
		  (if (cdr vardefs)
		      (list (macroexpand-1 `(needs ,(cdr vardefs) ,@body)))
		    body))))
    (append `(when ,vardef)
		  (if (cdr vardefs)
		      (list (macroexpand-1 `(needs ,(cdr vardefs) ,@body)))
		    body)))))
#+END_SRC

=needs= acts similarly to =when-let= except that for every variable decalared in its header
it has an optional third argument – a form to be evaluated in case the variable turns out to be ~nil~.

#+BEGIN_SRC emacs-lisp :results drawer
(print (macroexpand-1 '(needs
((x (f 1) (message "could not define x"))
 (y (g x) (message "could not define y")))
(message "let's rock")
(- x y))))
#+END_SRC

#+RESULTS:
:RESULTS:
(let ((x (f 1))) (if x (let ((y (g x))) (if y (progn (message let's rock) (- x y)) (message could not define y))) (message could not define x)))
:END:

← let me format the output:
#+BEGIN_SRC emacs-lisp
(let ((x (f 1)))
  (if x
    (let ((y (g x)))
      (if y
        (progn
	  (message "let's rock")
	  (- x y))
	(message "could not define y")))
    (message could "not define x")))
#+END_SRC


For other usage examples, see [[https://github.com/chalaev/cloud][cloud]] project, e.g.:
#+BEGIN_SRC emacs-lisp :results drawer
(print (macroexpand-1 '(needs ((col-value (begins-with str (car column)) (bad-column "action" (cdr column))))
(aset action (cdr column) (car col-value))
(setf str (cdr col-value)))))
#+END_SRC

Sometimes I need a slightly changed version of =needs= that does not create a local variable,
setting the value of a global one instead:
#+BEGIN_SRC emacs-lisp :tangle generated/macros.el
(defmacro first2(ll) `(firstN ,ll 2))
(defmacro needs-set (vardefs &rest body)
  "needs with 'let' being replaced with 'setf'"
  (let ((vardef (car vardefs)))
    (if (cddr vardef)
      `(if-set (,(first2 vardef))
	  ,(if (cdr vardefs)
	       (macroexpand-1 `(needs-set ,(cdr vardefs) ,@body))
	     `(progn ,@body))
	  ,(caddr vardef))
      `(when-set (,(car vardefs))
	   ,(if (cdr vardefs)
	       (macroexpand-1 `(needs-set ,(cdr vardefs) ,@body))
	      `(progn ,@body))))))
#+END_SRC

Example #1:
#+BEGIN_SRC emacs-lisp :results drawer
(print (macroexpand-1 '(needs-set
((x (f 1) (message "did not set x"))
 (y (g x) (message "did not set y")))
(message "let's rock")
(- x y))))
#+END_SRC

#+RESULTS:
:RESULTS:
(if-set ((x (f 1)))
 (if-set ((y (g x)))
 (progn (message let's rock) (- x y))
 (message did not set y))
 (message did not set x))
:END:

and here is the formatted result:
#+BEGIN_SRC emacs-lisp
(if-set ((x (f 1)))
  (if-set ((y (g x)))
     (progn
       (message let's rock)
       (- x y))
     (message "did not set y"))
  (message "did not set x"))
#+END_SRC

Example #2 (from the [[https://github.com/chalaev/cloud][cloud project]]):
#+BEGIN_SRC emacs-lisp :results drawer
(print (macroexpand-1 '(needs-set
  ((conf (read-conf* (local/config)))
   (remote/files (cdr (assoc "remote/files" conf)) (clog :error "specify 3-symbol contents name (remote/files) in %s" (local/config)))
   (N-CPU-cores (string-to-number
 (or
 (cdr (assoc "number-of-CPU-cores" conf))
 (clog :warning "specify number-of-CPU-cores in %s" (local/config)
 "1"))))
   (password (cdr (assoc "password" conf)) (clog :error "specify password in %s" (local/config)))
   (remote-dir (cdr (assoc "remote-directory" conf)) (clog :error "specify remote-directory in %s" (local/config))))
conf)))
#+END_SRC

#+RESULTS:
:RESULTS:
(when-set ((conf (read-conf* (local/config)))) (if-set ((remote/files (cdr (assoc remote/files conf)))) (when-set ((N-CPU-cores (string-to-number (or (cdr (assoc number-of-CPU-cores conf)) (clog :warning specify number-of-CPU-cores in %s (local/config) 1))))) (if-set ((password (cdr (assoc password conf)))) (if-set ((remote-dir (cdr (assoc remote-directory conf)))) (progn conf) (clog :error specify remote-directory in %s (local/config))) (clog :error specify password in %s (local/config)))) (clog :error specify 3-symbol contents name (remote/files) in %s (local/config))))
:END:
and here is the formatted result:
#+BEGIN_SRC emacs-lisp
(when-set ((conf (read-conf* (local/config))))
  (if-set ((remote/files (cdr (assoc remote/files conf))))
    (when-set ((N-CPU-cores (string-to-number (or (cdr (assoc number-of-CPU-cores conf)) (clog :warning specify number-of-CPU-cores in %s (local/config) 1)))))
      (if-set ((password (cdr (assoc password conf))))
        (if-set ((remote-dir (cdr (assoc remote-directory conf))))
	  (progn conf)
	  (clog :error specify remote-directory in %s (local/config)))
	(clog :error specify password in %s (local/config))))
    (clog :error specify 3-symbol contents name (remote/files) in %s (local/config))))
#+END_SRC

* safe-mkdir
=safe-mkdir= attempts to create a directory; in case of errors it raises no conditions (exceptions).

Its argument ~dirname~ 
- may start with "~/" and
- may or may not end with "/".

#+BEGIN_SRC emacs-lisp :tangle generated/file-functions.el
(defun safe-mkdir (dirname)
"creates a directory returning the report"
(condition-case err
  (progn (make-directory dirname)  (list t))
 (file-already-exists (cons nil :exists))
 (file-error (cons nil :permission))))
#+END_SRC

=safe-mkdir= returns =cons=; its =car= is
- ~nil~ in case the directory can not be created (then =cdr= explains why), or
- ~t~ in case the directory was sucessfully created,
as one can see from the table generated by the following output:
#+BEGIN_SRC emacs-lisp :var RS=randstr
(let* ((test-dirs (list
         (cons "o.k." RS)
         (cons "not allowed to" (concat "/etc/" RS))
         (cons "already exists" "/"))); BTW, how should one represent root directory in MS-DOS/Windows?
       (result (mapcar #'(lambda(d) (cons (car d) (cons-to-list (safe-mkdir (cdr d))))) test-dirs)))
(safe-delete-dir RS); removing temporary directory
result)
#+END_SRC

#+RESULTS:
| o.k.           | t   | nil         |
| not allowed to | nil | :permission |
| already exists | nil | :exists     |

In SBCL I must know if the directory =dirname= existed before I attempted to create it,
so I have to use (low-level) [[https://github.com/sbcl/sbcl/blob/master/contrib/sb-posix/posix-tests.lisp][sb-posix:mkdir]] function:
#+BEGIN_SRC lisp :tangle generated/files.lisp
(defun safe-mkdir (dirname)
(handler-case (cons t (sb-posix:mkdir dirname #o770))
  (sb-posix:syscall-error (c)
    (cons nil
      (case (sb-posix:syscall-errno c)
        (13 :permission)
        (17 :exists)
        (2 :parent)
        (otherwise (cons :unknown (sb-posix:syscall-errno c))))))))
#+END_SRC
– works on SBCL only.

#+BEGIN_SRC lisp :var RS=randstr
(defun cons-to-list(co)
"transforms cons to list"
(if (consp co)
  (cons (car co) (cons-to-list (cdr co)))
  (list co)))
(let* ((dir (merge-pathnames RS (user-homedir-pathname))); temporary directory name
(test-dirs (list
  (cons "o.k." dir)
  (cons "not allowed to" (concat "/etc/" RS))
  (cons "already exists" "/"))); BTW, how should one represent root directory in MS-Windows?
       (result (mapcar #'(lambda(d) (cons (car d) (safe-mkdir (cdr d)))) test-dirs)))
(uiop:delete-empty-directory dir); removing temporary directory
(mapcar #'cons-to-list result))
#+END_SRC

#+RESULTS:
| o.k.           | T   | 0           |
| not allowed to | NIL | :PERMISSION |
| already exists | NIL | :EXISTS     |

* directory-lock
=(directory-lock locked-dir by body...)= attempts to create directory =locked-dir=.
(Linux kernel is made in such a way, that if several processes are simultaneously trying to create nonexistent directory, *only one* of them succeeds.)

If the directory was sucessfully created,
1. file "by" is created inside it containing the string ~by~, and
2. forms ~body~ are evaluated.

Similarly to [[safe-mkdir]], =directory-lock= returns =cons=; its =car= is ~t~ in case all =directory-lock= operations went through successfully:
the directory was successfully locked and later unlocked.

In this case, =(cdr (directory-lock ...))= contains the result of ~body~ evaluation.

#+BEGIN_SRC emacs-lisp :tangle generated/macros.el
(defmacro directory-lock(locked-dir by &rest body)
(let ((LD (gensym "LD")) (lock-file (gensym "LF")) (mkdir (gensym "MD")) (result (gensym "r")) (unlock (gensym "u")))
`(let* ((,LD (file-name-as-directory ,locked-dir))
        (,lock-file (concat ,LD "by"))
        (,mkdir (safe-mkdir ,LD)))
  (ifn (car ,mkdir) (cons nil (cons :lock ,mkdir))
  (write-region ,by nil ,lock-file)
  (let ((,result (progn ,@body)))
    (if-let ((,unlock (and (rm ,lock-file) (safe-delete-dir ,LD))))
      (cons t ,result)
      (cons nil (cons :unlock (cons ,unlock ,result)))))))))
#+END_SRC

*No matter how many processes are trying to lock the same directory simultaneously, at most one will succeed.*

If something went wrong, =(car (directory-lock ...))= is =nil=,
and the problem is described by =(cadr (directory-lock ...))= which is
- ~:lock~ in case the directory could not be locked, or
- ~:unlock~ in case the directory could not be unlocked. That is, we were able to create the directory ~locked-dir~,
  then evaluated the ~body~ forms, but finally could not erase ~locked-dir~.

Example – locking remote directory: 
#+BEGIN_SRC emacs-lisp :results drawer
(print (macroexpand-1 '(directory-lock "/mnt/server/code-name" (system-name)
(body-1) (body-2))))
#+END_SRC

#+RESULTS:
:RESULTS:
(let* ((ld43 (file-name-as-directory /mnt/server/code-name)) (lf44 (concat ld43 by)) (md45 (safe-mkdir ld43))) (ifn (car md45) (cons nil (cons :lock md45)) (write-region (system-name) nil lf44) (let ((r46 (progn (body-1) (body-2)))) (if-let ((u47 (and (rm lf44) (safe-delete-dir ld43)))) (cons t r46) (cons nil (cons :unlock (cons u47 r46)))))))
:END:

Formatted result:
#+BEGIN_SRC emacs-lisp
(let* ((ld43 (file-name-as-directory "/mnt/server/code-name"))
       (lf44 (concat ld43 "by"))
       (md45 (safe-mkdir ld43)))
  (ifn (car md45) (cons nil (cons :lock md45))
       (write-region (system-name) nil lf44)
       (let ((r46 (progn (body-1) (body-2))))
	 (if-let ((u47 (and (rm lf44) (safe-delete-dir ld43))))
	     (cons t r46)
	   (cons nil (cons :unlock (cons u47 r46)))))))
#+END_SRC

Common Lisp code is more advanced than the elisp one:
#+BEGIN_SRC emacs-lisp :tangle generated/macros.lisp
(defmacro directory-lock(locked-dir by &rest body)
(let ((LD (gensym "ld")) (lock-file (gensym "LF")) (mkdir (gensym "md")) 
      (result (gensym "r")))
`(let* ((,LD (uiop:ensure-directory-pathname  ,locked-dir))
        (,mkdir (safe-mkdir ,LD)))
  (ifn (car ,mkdir) (cons nil (cons :lock (cdr ,mkdir)))
(let ((,lock-file (merge-pathnames #p"by" ,LD)))
  (echo-to-file ,lock-file ,by)
  (let ((,result (progn ,@body)))
#+END_SRC
← requires =echo-to-file= from ~generated/files.lisp~

In case we could not unlock the directory, let us not go into the details:
#+BEGIN_SRC emacs-lisp :tangle generated/macros.lisp
(ifn (car (rm ,lock-file)) (cons nil (cons :file ,result))
(ifn (car (rmdir ,LD)) (cons nil (cons :dir ,result))
(cons t ,result)))))))))
#+END_SRC

Example: 
#+BEGIN_SRC lisp :results drawer
(macroexpand-1 '(directory-lock "/mnt/server/code-name" (system-name)
  (body-1) (body-2)))
#+END_SRC

Formatted result:
#+BEGIN_SRC lisp
(LET* ((#:|ld490| (UIOP/PATHNAME:ENSURE-DIRECTORY-PATHNAME "/mnt/server/code-name"))
       (#:|md492| (SAFE-MKDIR #:|ld490|)))
  (IFN (CAR #:|md492|) (CONS NIL (CONS :LOCK (CDR #:|md492|)))
   (LET ((#:LF491 (MERGE-PATHNAMES #P"by" #:|ld490|)))
     (ECHO-TO-FILE #:LF491 (SYSTEM-NAME))
     (LET ((#:|r493| (PROGN (BODY-1) (BODY-2))))
       (IFN (CAR (RM #:LF491)) (CONS NIL (CONS :FILE #:|r493|))
        (IFN (CAR (RMDIR #:|ld490|)) (CONS NIL (CONS :DIR #:|r493|))
         (CONS T #:|r493|)))))))
#+END_SRC

* remo & drop
Remo is a helper for =drop= macro which removes elements from an array:
#+BEGIN_SRC emacs-lisp :tangle generated/functions.el
(defun remo (from-where &rest what)
  (if (cdr what)
      (remo
       (apply #'remo (cons from-where (cdr what)))
       (car what))
 (remove (car what) from-where)))
(defmacro drop (from-where &rest what)
  `(setf ,from-where (remo ,from-where ,@what)))
#+END_SRC
Test:
#+BEGIN_SRC emacs-lisp :results drawer
(let ((ll '(1 2 3 4 5 6)))
  (drop ll 2 4)
  ll)
#+END_SRC

#+RESULTS:
:RESULTS:
(1 3 5 6)
:END:

For now CL code will be simpler:
#+BEGIN_SRC lisp :tangle generated/macros.lisp
(declaim (notinline id))
(defun id(x) x)
(defmacro drop-if (what from-where &key (key #'id) (test #'eql))
  `(setf ,from-where (remove ,what ,from-where :key ,key :test ,test)))
#+END_SRC

#+BEGIN_SRC lisp
(macroexpand-1 '(drop-if name hooks :key #'car :test #'string=))
#+END_SRC
results in
#+BEGIN_SRC lisp
(SETF HOOKS (REMOVE NAME HOOKS :KEY #'CAR :TEST #'STRING=))
#+END_SRC

* emacs lisp
** emacs configuration in ~/.emacs
You probably want to adjust this code to your needs before pasting it into your =~/.emacs=:
#+BEGIN_SRC emacs-lisp :tangle generated/dot.emacs :shebang ";; -*- mode: Emacs-Lisp;  lexical-binding: t; -*-"
;; Generated from https://notabug.org/shalaev/lisp-goodies/src/master/shalaev.org
;; See explanations therein. Edit this code before using it.

(defun barename (FN)
  (let ((SS (split-string (file-name-nondirectory FN)  "\\." t)))
    (mapconcat #'(lambda(x)x) (butlast SS) ".")))
#+END_SRC
=printangle= returns the list of exported (tangled) files
#+BEGIN_SRC emacs-lisp :tangle generated/dot.emacs
(defun printangle(FN)
  "to be used in Makefile instead of org-babel-tangle-file"
  (let ((l (length default-directory)))
     (apply #'concat (mapcar #'(lambda(x) (substring (format "%s " x) l)) (org-babel-tangle-file FN)))))
#+END_SRC
← I am using it in my [[https://github.com/chalaev/cl-simple-logger/blob/master/Makefile][Makefile]]s.

Obsoleted by =file-name-nondirectory=:
#+BEGIN_SRC 
(defun basename (FN) (car(last(split-string FN "/" t))))
#+END_SRC

The following function is designed to prevent multiple evaluation of one and the same file:
#+BEGIN_SRC emacs-lisp :tangle generated/dot.emacs
(defvar *loaded* nil "prevents duplicate evaluation of files")
(defun load-file* (x &optional el-prefix)
  (let ((FN (file-chase-links 
             (if (= ?/ (aref x 0)) x
               (concat (or el-prefix 
 (concat (getenv "HOME") "/"))
x)))))
    (unless (member (car (last (split-string FN "\\." t))) '("el" "elc"))
      (setf FN (concat FN ".el")))
    (unless (member FN *loaded*) (load-file FN) (push (barename FN) *loaded*))))
#+END_SRC
Every time I start emacs, I load several files:
#+BEGIN_SRC emacs-lisp :tangle generated/dot.emacs
(mapcar #'(lambda(x) (load-file* x "~/programming/emacs/"))
	'("macros" "functions" "logging"  ....))
#+END_SRC

My ~backup~ system does not save files having the group ~tmp~.
I use this group to mark all generated (tangled) files:
#+BEGIN_SRC emacs-lisp :tangle generated/dot.emacs
(defun after-tangle()
  "mark tangled files as non-backupable (chgrp tmp files) and non-excecutable"
  (let ((FN (buffer-file-name)))
#+END_SRC
The following line is equivalent to =chmod a-x FN=:
#+BEGIN_SRC emacs-lisp :tangle generated/dot.emacs
    (set-file-modes FN (logand #o666 (perms-from-str (nth 8 (file-attributes FN 'string)))))
    (chgrp "tmp" FN)))
(add-hook 'org-babel-post-tangle-hook #'after-tangle)
#+END_SRC
so they are not backuped.

(found online) =run-init-block=  runs ~init~ code block when loading an org-file:
#+BEGIN_SRC emacs-lisp :tangle generated/dot.emacs
(defun run-init-block ()
  (org-babel-goto-named-src-block "init")
  (org-babel-execute-src-block))
#+END_SRC

** replacing cl.el
Just following Stallman's advice, I try to avoid using =cl.el=;
=generated/cl.el= will be my (incomplete for now) replacement for  =cl.el=
to be loaded as follows:
#+BEGIN_SRC emacs-lisp
(unless (functionp 'gensym)
  (load (concat (file-name-as-directory "generated") "cl.el")))
#+END_SRC

*Problem:* I am not sure if eliminating =cl.el= really makes sence because
apparently it is widely used; for example, =M-x org-babel-tangle= uses =cl.el= (although does not require it).

*** gensym
#+BEGIN_SRC emacs-lisp :tangle generated/cl.el :shebang ";; -*- mode: Emacs-Lisp;  lexical-binding: t; -*-"
;; generated from https://notabug.org/shalaev/lisp-goodies/src/master/shalaev.org
(let ((counter 0))
  (defun gensym(&optional starts-with)
    "for those who miss gensym from Common Lisp"
    (unless starts-with (setf starts-with "gs"))
    (let (sym)
      (while (progn
               (setf sym (make-symbol (concat starts-with (number-to-string counter))))
               (or (special-form-p sym) (functionp sym) (macrop sym) (boundp sym)))
        (incf counter))
      (incf counter)
      sym)))
#+END_SRC
=gensym= is used in macros, e.g.
#+BEGIN_SRC emacs-lisp :results drawer
(let ((ms (gensym "a")))
  `(let ((,ms 0))
     (1+ ,ms)))
#+END_SRC

#+RESULTS:
:RESULTS:
(let ((a3 0)) (1+ a3))
:END:

*** find
#+BEGIN_SRC emacs-lisp :tangle generated/cl.el
(defun find(item seq &optional key test)
  (when seq
  (let ((test (or test #'=)))
    (when-let ((CS (car seq)))
      (if-let ((found (funcall test
			       item
			       (if key (funcall key CS) CS))))
	  CS
	(find item (cdr seq) key test))))))
#+END_SRC

#+BEGIN_SRC emacs-lisp :results drawer
(find 3 '( 1 2 3 4 5))
#+END_SRC

#+RESULTS:
:RESULTS:
3
:END:

#+BEGIN_SRC emacs-lisp :results drawer
(find 4 '((1 2) (3 4) (5 6)) #'cadr)
#+END_SRC

#+RESULTS:
:RESULTS:
(3 4)
:END:

*** decf and incf
#+BEGIN_SRC emacs-lisp :tangle generated/cl.el
(unless (or (boundp 'decf) (functionp 'decf) (macrop 'decf))
(defmacro decf (var &optional amount)
  (unless amount (setf amount 1))
  `(setf ,var (- ,var ,amount))))
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle generated/cl.el
(unless (or (boundp 'incf) (functionp 'incf) (macrop 'incf))
(defmacro incf (var &optional amount)
  (unless amount (setf amount 1))
  `(setf ,var (+ ,var ,amount))))
#+END_SRC

*** flet
It uses =macrolet= which is also defined in  =cl.el= :)

#+BEGIN_SRC emacs-lisp :tangle generated/cl.el
(defmacro flet(fun-defs &rest body)
(let ((GSs (mapcar #'(lambda(FD) (cons (car FD) (gensym))) fun-defs)))
`(let ,(mapcar #'(lambda(FD)
(list (cdr (assoc (car FD) GSs))
`(lambda ,(cadr FD) ,@(cddr FD)))) fun-defs)
(macrolet ,(mapcar #'(lambda(FD)
(list (car FD) (cadr FD) `(funcall ,(cdr (assoc (car FD) GSs)) ,@(cadr FD)))) fun-defs)
 ,@body))))
#+END_SRC

#+BEGIN_SRC emacs-lisp :results drawer
(print (macroexpand-1 '(flet ((f1(x) (1+ x)) (f2(x) (1- x)))
(+ 1 2 (f1 3))
(* 1 2 (f2 3)))))
#+END_SRC

#+RESULTS:
:RESULTS:
(let ((G38 (lambda (x) (1+ x)))
      (G39 (lambda (x) (1- x))))
(macrolet ((f1 (x) (funcall G38 x)) 
           (f2 (x) (funcall G39 x)))
 (+ 1 2 (f1 3))
 (* 1 2 (f2 3))))
:END:

To be improved: variable names in =macrolet= should be generated by =gensym=.

** short pieces of code
*** case*
~case*~ is not identical to =case= from =cl.el=:
it uses arbitrary test function:
#+BEGIN_SRC emacs-lisp :tangle generated/macros.el :shebang ";; -*- mode: Emacs-Lisp;  lexical-binding: t; -*-"
;; generated from https://notabug.org/shalaev/lisp-goodies/src/master/shalaev.org
(defmacro case* (expr test &rest cases)
  "case with arbitrary test function"
  (let ((v (gensym "v")))
    `(let ((,v ,expr))
       (cond
        ,@(mapcar #'(lambda (VR)
(let ((val (car VR)) (rest (cdr VR)))
  (if (eql val 'otherwise)
      `(t ,@rest)
    `((,test ,v ,val) ,@rest))))
 cases)))))
#+END_SRC
A simple example:
#+BEGIN_SRC emacs-lisp :results drawer
(macroexpand-1 
 `(case* (+ 1 2) =
    (choice-1 (message "choice-1"))
    (choice-2 (message "choice-2"))
    (otherwise (message "no match"))))
#+END_SRC

#+RESULTS:
:RESULTS:
(let ((v13 (+ 1 2)))
 (cond 
((= v13 choice-1) (message choice-1))
((= v13 choice-2) (message choice-2))
(t (message no match))))
:END:

Another example is also self-explanatory:
#+BEGIN_SRC emacs-lisp :results drawer
(let ((x 32) (choice-1 22)  (choice-2 33))
  (case* (1+ x) =
    (choice-1 (message "choice-1"))
    (choice-2 (message "choice-2"))
    (otherwise (message "no match"))))
#+END_SRC

#+RESULTS:
:RESULTS:
choice-2
:END:

*** case-let
=case-let= is probably *useless*:
as of 2020-11-04 I think that small convenience due to slight code size reduction does not compensate new symbol introduction, so =case-let= remains unused for now.

Sometimes we may want to access the let-variable name generated in =case*=;
so we define =case-let= which is only a slightly modified version of =case*=:
#+BEGIN_SRC emacs-lisp
(defmacro case-let (let-var expr test &rest cases)
  "case* with let expriable named by the user"
    `(let ((,let-var ,expr))
       (cond
        ,@(mapcar #'(lambda (VR)
(let ((val (car VR)) (rest (cdr VR)))
  (if (eql val 'otherwise)
      `(t ,@rest)
    `((,test ,let-var ,val) ,@rest))))
 cases))))
#+END_SRC
A simple example:
#+BEGIN_SRC emacs-lisp :results drawer
(macroexpand-1 
 `(case-let x (+ 1 2) =
    (choice-1 (format "1: x=%d" x))
    (choice-1 (format "2: x=%d" x))
    (otherwise (message "no match"))))
#+END_SRC

#+RESULTS:
:RESULTS:
(let ((x (+ 1 2))) (cond ((= x choice-1) (format 1: x=%d x)) ((= x choice-1) (format 2: x=%d x)) (t (message no match))))
:END:

*** when-set and unless-set
Sometimes instead of =when-let= I use somewhat similar =when-set= macro.
=when-set= is similar to =when-let= except for that it uses existing global variables instead of creating local ones.

#+begin_note
Global variable values will *not* be set to ~nil~.
#+end_note

#+BEGIN_SRC emacs-lisp :tangle generated/macros.el
(defmacro when-set (vars &rest body)
  "when-let using global variable instead of defining local one"
(let ((GV (gensym)))
  `(let ((,GV ,(cadar vars)))
     ,(if (cdr vars)
	  `(when ,GV
              (setf ,(caar vars) ,GV)
	     ,(macroexpand-1 `(when-set ,(cdr vars) ,@body)))
	(append `(when ,GV (setf ,(caar vars) ,GV)) body)))))
#+END_SRC

#+BEGIN_SRC emacs-lisp :results drawer
(print (macroexpand-1
 `(when-set ((CN (clouded (aref newDBrec cipher))) (NFE (not (file-exists-p CN))))
    (+ 1 2)
    (- 1 2))))
#+END_SRC

#+RESULTS:
:RESULTS:
(let ((it15 (clouded (aref newDBrec cipher))))
 (when it15 (setf CN it15) 
   (let ((it16 (not (file-exists-p CN))))
      (when it16 (setf NFE it16) (+ 1 2) (- 1 2)))))
:END:

=unless-set= is similar to =when-set=:
#+BEGIN_SRC emacs-lisp :tangle generated/macros.el
(defmacro unless-set (vars &rest body)
  "unless-let using global variable instead of defining local one"
(let ((GV (gensym)))
  `(let ((,GV ,(cadar vars)))
     ,(if (cdr vars)
	  `(if ,GV
              (setf ,(caar vars) ,GV)
	     ,(macroexpand-1 `(unless-set ,(cdr vars) ,@body)))
	(append `(if ,GV (setf ,(caar vars) ,GV)) body)))))
#+END_SRC

#+BEGIN_SRC emacs-lisp :results drawer
(print (macroexpand-1
 `(unless-set ((CN (aref newDBrec cipher)) (FE (file-exists-p CN)))
    (+ 1 2)
    (- 1 2))))
#+END_SRC

#+RESULTS:
:RESULTS:
(let ((g30 (aref newDBrec cipher)))
  (if g30
     (setf CN g30) 
(let ((g31 (file-exists-p CN)))
    (if g31 (setf FE g31)
       (+ 1 2)
       (- 1 2)))))
:END:

*** if-set
#+BEGIN_SRC emacs-lisp :tangle generated/macros.el
(defmacro if-set (vars &rest body)
  (let ((if-true (gensym "it")) (result (gensym "r")))
    `(let (,if-true ,result)
       (setf ,result (when-set ,vars
		  (setf ,if-true t)
		  ,(car body)))
       (if ,if-true ,result
	 ,@(cdr body)))))
#+END_SRC

#+BEGIN_SRC emacs-lisp :results drawer
(print (macroexpand-1
  '(if-set ((x 1) (y (1+ x)))
     (+ x y) (- x y) (* x y))))
#+END_SRC

#+RESULTS:
:RESULTS:
(let (it28 r29) 
(setf r29 (when-set ((x 1) (y (1+ x))) (setf it28 t) (+ x y)))
 (if it28 r29 (- x y) (* x y)))
:END:

#+BEGIN_SRC emacs-lisp :tangle generated/macros.el
(defmacro ifn-set (vars ifno &rest body)
`(if-set ,vars
   (progn ,@body)
   ,ifno))
#+END_SRC

#+BEGIN_SRC emacs-lisp :results drawer
(print (macroexpand-1 (macroexpand-1 
'(ifn-set
  ((remote/files (cdr (assoc "remote/files" conf)))
   (N-CPU-cores (string-to-number (or (cdr (assoc "number-of-CPU-cores" conf)) "1")))
   (password  (cdr (assoc "password" conf)))
   (remote-dir (cdr (assoc "remote-directory" conf))))
(clog :error "something is missing or wrong in the configuration file" remote-dir)
(print "everything is ok")
(print "so we proceed")))))
#+END_SRC

#+RESULTS:
:RESULTS:
(let (it32 r33) 
  (setf r33
	(when-set ((remote/files (cdr (assoc remote/files conf)))
		   (N-CPU-cores (string-to-number (or (cdr (assoc number-of-CPU-cores conf)) 1)))
		   (password (cdr (assoc password conf)))
		   (remote-dir (cdr (assoc remote-directory conf))))
		  (setf it32 t)
		  (progn (print everything is ok) (print so we proceed))))
  (if it32
      r33
    (clog :error something is missing or wrong in the configuration file remote-dir)))
:END:

*** cond-let
=cond-let= is a natural generalization of =if-let=:
#+BEGIN_SRC emacs-lisp :tangle generated/macros.el
(defmacro cond-let (&rest conds)
  "cond with let"
  (let ((c (car conds)) (r (cdr conds)))
    (if (equal (car c) 'otherwise) `(progn ,@(cdr c))
    (if r
	`(if-let ,(car c) (progn ,@(cdr c)) ,(macroexpand-1 `(cond-let ,@r)))
	`(when-let ,(car c) ,@(cdr c))))))
#+END_SRC

#+BEGIN_SRC emacs-lisp :results drawer
(print (macroexpand-1
  '(cond-let
    (((x 1) (y (1+ x))) (+ x y) (- x y) (* x y))
    (((x 3) (y (1+ x))) (+ x y) (- x y) (/ x y))
    (otherwise 22 33))))
#+END_SRC

#+RESULTS:
:RESULTS:
(if-let ((x 1) (y (1+ x)))
 (progn (+ x y) (- x y) (* x y)) 
(if-let ((x 3) (y (1+ x)))
 (progn (+ x y) (- x y) (/ x y))
 (progn 22 33)))
:END:

Formatted result:
#+BEGIN_SRC emacs-lisp
(if-let ((x 1) (y (1+ x)))
  (progn (+ x y) (- x y) (* x y))
  (if-let ((x 3) (y (1+ x))) 
    (progn (+ x y) (- x y) (/ x y))
    (progn 22 33)))
#+END_SRC

Common Lisp version is the same as elisp one:
#+BEGIN_SRC emacs-lisp :tangle generated/macros.lisp
(defmacro cond-let(&rest conds)
  "cond with let"
  (let ((c (car conds)) (r (cdr conds)))
    (if (equal (car c) 'otherwise) `(progn ,@(cdr c))
    (if r
	`(if-let ,(car c) (progn ,@(cdr c)) ,(macroexpand-1 `(cond-let ,@r)))
	`(when-let ,(car c) ,@(cdr c))))))
#+END_SRC

*** email
A non-interactive =email= function:
#+BEGIN_SRC emacs-lisp :tangle generated/functions.el :shebang ";; -*- mode: Emacs-Lisp;  lexical-binding: t; -*-"
(defun email (addr &optional subject body)
  "fast non-interactive way to send an email"
  (compose-mail addr (if subject subject ""))
  (when body (insert body))
  (message-send-and-exit))
#+END_SRC
– will work if mailing system (~exim4~ in my case) is configured properly.

*** pos
Position of an element in a list:
#+BEGIN_SRC emacs-lisp :tangle generated/functions.el
(defun pos (el ll)
  (let ((i 0) r)
  (dolist (e ll r)
    (if (eql e el)
	(setf r i)
      (incf i)))))
#+END_SRC

*** perms-from-str
When I ask ~emacs~ to show me file's permissions, it provides a text string (e.g., "-rw-rw----") instead of a number.
The following function produces a number from such a string:
#+BEGIN_SRC emacs-lisp :tangle generated/functions.el
(defun perms-from-str (str)
"parses file mode string into integer"
  (let ((text-mode (reverse (cdr (append str nil)))) (mode 0) (fac 1))
    (loop for c in text-mode for i from 0
          unless (= c ?-) do (incf mode fac)
          do (setf fac (* 2 fac)))
    mode))
#+END_SRC
Usage example:
#+BEGIN_SRC emacs-lisp :results drawer
(perms-from-str "-rw-rw----")
#+END_SRC

#+RESULTS:
:RESULTS:
432
:END:

*** perms-to-str
=perms-to-str= is just the opposite of [[perms-from-str]].
#+BEGIN_SRC emacs-lisp :results drawer
(let ((ll '((1 . 0))))
  (dotimes (i 8 ll)
     (push (cons (* 2 (caar ll)) (mod (1+ i) 3))  ll)))
#+END_SRC

#+RESULTS:
:RESULTS:
((256 . 2) (128 . 1) (64 . 0) (32 . 2) (16 . 1) (8 . 0) (4 . 2) (2 . 1) (1 . 0))
:END:

#+BEGIN_SRC emacs-lisp :results drawer
(let ((ll '((1 . 0))))
  (dotimes (i 8 ll)
     (push (cons (* 2 (caar ll)) (mod (1+ i) 3))  ll)))
#+END_SRC

#+RESULTS:
:RESULTS:
((256 . 2) (128 . 1) (64 . 0) (32 . 2) (16 . 1) (8 . 0) (4 . 2) (2 . 1) (1 . 0))
:END:

#+BEGIN_SRC emacs-lisp :results drawer
(let ((ll '((1 . 0))) (file-mode #o664))
  (apply #'concat (mapcar
		   #'(lambda(x) (format "%c" (if (= 0 (logand file-mode (car x))) ?- (aref "xwr" (cdr x)))))
  (dotimes (i 8 ll)
     (push (cons (* 2 (caar ll)) (mod (1+ i) 3))  ll)))))
#+END_SRC

#+RESULTS:
:RESULTS:
rw-rw-r--
:END:
#+BEGIN_SRC emacs-lisp :tangle generated/functions.el
(defun perms-to-str(file-mode)
"formats integer file mode into string"
(let ((ll '((1 . 0))))
  (apply #'concat (mapcar
		   #'(lambda(x) (format "%c" (if (= 0 (logand file-mode (car x))) ?- (aref "xwr" (cdr x)))))
  (dotimes (i 8 ll)
     (push (cons (* 2 (caar ll)) (mod (1+ i) 3))  ll))))))
#+END_SRC
Usage example:
#+BEGIN_SRC emacs-lisp :results drawer
(perms-to-str #o667)
#+END_SRC

#+RESULTS:
:RESULTS:
rw-rw-rwx
:END:

*** parsing time and date
#+BEGIN_SRC emacs-lisp :tangle generated/functions.el
(defun parse-date (str)
  (mapcar 'string-to-number
	  (cond
 ((string-match "\\([0-9]\\{4\\}\\)[/-]\\([0-9][0-9]\\)[/-]\\([0-9][0-9]\\)" str) (mapcar #'(lambda (x) (match-string x str)) '(3 2 1)))
 ((string-match "\\([0-9][0-9]\\)[/-]\\([0-9][0-9]\\)[/-]\\([0-9]\\{4\\}\\)" str) (mapcar #'(lambda (x) (match-string x str)) '(2 1 3)))
 ((string-match "\\([0-9][0-9]\\)\\.\\([0-9][0-9]\\)\\.\\([0-9]\\{4\\}\\)" str) (mapcar #'(lambda (x) (match-string x str)) '(1 2 3)))
 ((string-match "\\([0-9][0-9]\\)/\\([0-9][0-9]\\)/\\([0-9]\\{2\\}\\)" str) (mapcar #'(lambda (x) (match-string x str)) '(2 1 3)))
 ((string-match "\\([0-9]\\{2\\}\\)[/-]\\([0-9][0-9]\\)" str) (append (mapcar #'(lambda (x) (match-string x str)) '(2 1)) (list (format-time-string "%Y" (current-time)))))
 (t (clog :error "date format not recognized in %s" str) nil))))
#+END_SRC
#+BEGIN_SRC emacs-lisp :tangle generated/functions.el
(defun parse-only-time (str)
  (firstN (parse-time-string str) 3))
#+END_SRC
#+BEGIN_SRC emacs-lisp :tangle generated/functions.el
(defun parse-date-time(str)
  (if (string-match "[0-9]\\{4\\}-[0-9][0-9]-[0-9][0-9] [0-9][0-9]:[0-9][0-9]" str)
      (parse-time-string str)
    (let ((SS (split-string str)))
      (append (parse-only-time (cadr SS))
	      (parse-date (car SS))))))
#+END_SRC
Example:
#+BEGIN_SRC emacs-lisp :results drawer
(cons (parse-only-time "16:09:37")
(mapcar #'(lambda(x) (format-time-string "%F %H:%M:%S %Z" (apply #'encode-time (parse-date-time x))))
 (list "10/21 14:54"
        "2020-10-10 14:54:40  EDT")))
#+END_SRC

#+RESULTS:
:RESULTS:
((37 9 16) 2020-10-21 14:54:00 EDT 2020-10-10 14:54:40 EDT)
:END:

*** simple stuff
#+BEGIN_SRC emacs-lisp :tangle generated/macros.el
(defmacro ifn (test ifnot &rest ifyes)
`(if (not ,test) ,ifnot ,@ifyes))
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle generated/functions.el
(defun firstN(lista N)
  "returning first N elments of the list"
  (when (and (< 0 N) (car lista))
    (cons (car lista) (firstN (cdr lista) (1- N)))))
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle generated/functions.el
(defvar *good-chars*
(let ((forbidden-symbols '(?! ?@ ?# ?$ ?% ?& ?* ?\( ?\) ?+ ?= ?/ ?{ ?} ?\[ ?\] ?: ?\; ?< ?> ?_ ?- ?| ?, ?. ?` ?' ?~ ?^ ?\")))
    (append
     (loop for i from ?A to ?Z unless (member i forbidden-symbols) collect i)
     (loop for i from ?a to ?z unless (member i forbidden-symbols) collect i)
     (loop for i from ?0 to ?9 unless (member i forbidden-symbols) collect i)))
"safe characters for file names")
(defun rand-str(N)
  (apply #'concat
     (loop repeat N collect (string (nth (random (length *good-chars*)) *good-chars*)))))
#+END_SRC

There is probably some standard function or macro doing this:
#+BEGIN_SRC lisp :tangle generated/macros.lisp
(defmacro end-push (what where)
  `(if ,where (push ,what (cdr (last ,where)))
      (push ,what ,where)))
#+END_SRC

#+BEGIN_SRC lisp :tangle generated/tests.lisp
(deftest end-push.1
(let (container)
  (end-push 1 container)
  container)
(1))
(deftest end-push.2
(let (container)
  (end-push 1 container)
  (end-push 2 container)
  container)
(1 2))
#+END_SRC

** file/directory fuctions
*** chgrp
#+BEGIN_SRC emacs-lisp :tangle generated/file-functions.el :shebang ";; -*- mode: Emacs-Lisp;  lexical-binding: t; -*-"
;; generated from https://notabug.org/shalaev/lisp-goodies/src/master/shalaev.org
(defun chgrp(group file-name)
  (= 0 (call-process "chgrp" nil nil nil group file-name)))
#+END_SRC
See also =dired-do-chown=.
*** rm (for files)
=rm= is a condition-free wrapper on top of =delete-file=.
#+BEGIN_SRC emacs-lisp :tangle generated/file-functions.el
(defun rm(FN)
"erases files only, not directories"
  (condition-case err (cons t (delete-file FN))
    (file-error (cons nil (error-message-string err)))))
#+END_SRC
Removal of nonexistent file does not lead to an error.

Example #1 – removing file with insufficient permissions produces "permission denied" error:
#+BEGIN_SRC emacs-lisp :results drawer
(rm  "/bin/ls")
#+END_SRC

#+RESULTS:
:RESULTS:
(nil . Removing old name: Permission denied, /bin/ls)
:END:

Example #2 – removing nonexistent file produces no error:
#+BEGIN_SRC emacs-lisp :results drawer
(rm  "/bin/there-is-no-such-file")
#+END_SRC

#+RESULTS:
:RESULTS:
(t)
:END:

Example #3 – an attempt to remove a directory produces an error:
#+BEGIN_SRC emacs-lisp :results drawer
(rm  "/tmp")
#+END_SRC

#+RESULTS:
:RESULTS:
(nil . Removing old name: is a directory: /tmp)
:END:

To (non-recursively) remove a directory, one can use =safe-delete-dir= instead:

*** safe-delete-dir
Non-recursive directory removal.

Its return result is similar to that of =rm= and =safe-mkdir=:
#+BEGIN_SRC emacs-lisp :tangle generated/file-functions.el
(defun safe-delete-dir (FN &optional recursive)
  (condition-case err (progn (delete-directory FN recursive) (list t))
    (file-error (cons nil (error-message-string err)))))
#+END_SRC

** logging system
It is probably too small to be packaged.
*** Short description
This code prints log messages to ~*Messages*~ buffer and saves them to log file =~/.emacs.d/elisp.log=.
Every message is formatted similarly to how it is done by =format= function.
*** Code
Global variable =*log-level*= controls how much information should be logged: the (default) zero value means
that all types of log-messages (:debug :warning :info :error) should be logged (saved);
the value 3 means that only error messages (marked with :error) will be logged:
#+BEGIN_SRC emacs-lisp :tangle generated/logging.el :shebang ";; -*- mode: Emacs-Lisp;  lexical-binding: t; -*-"
;; generated from https://notabug.org/shalaev/lisp-goodies/src/master/shalaev.org
(unless (boundp '*log-level*) (defvar *log-level* 0))
(unless (boundp '*emacs-d*) (defvar *emacs-d* (concat (getenv "HOME") "/.emacs.d/")))
#+END_SRC
Log messages are accumulated in =*file-acc-buffer*=
#+BEGIN_SRC emacs-lisp :tangle generated/logging.el
(unless (boundp '*file-acc-buffer*) (defvar *file-acc-buffer* nil))
(defvar *last-FLD* nil "saves last day printed to the log file")
#+END_SRC
and once in a while (when the number of queued messages >30 or before quitting ~emacs~) appended to the file =~/.emacs.d/elisp.log=:
#+BEGIN_SRC emacs-lisp :tangle generated/logging.el
(defun clog-flush()
  "save log messages to file for debugging"
  (when (= 0 *log-level*)
    (with-temp-buffer
      (let ((today-str (format-time-string "%04Y-%02m-%02d" (current-time))))
	(unless (string= today-str *last-FLD*)
	  (setf *last-FLD* today-str)
	  (insert today-str) (newline))
	(dolist (msg (reverse *file-acc-buffer*))
	  (insert msg) (newline)))
      (append-to-file (point-min) (point-max) (concat *emacs-d* "elisp.log")))
    (setf *file-acc-buffer* nil)))
#+END_SRC
Since we have [[https://www.emacswiki.org/emacs/EmacsLispLimitations][no multi-threading in elisp]], we do not need to introduce any lock functions.
#+BEGIN_SRC emacs-lisp :tangle generated/logging.el
(defun file-acc-push(msg)
  (push msg *file-acc-buffer*)
  (when (< 30 (length *file-acc-buffer*)) (clog-flush)))
#+END_SRC
The main logging function:
#+BEGIN_SRC emacs-lisp :tangle generated/logging.el
(defun clog (level fstr &rest args)
  "simple logging function" ; level is one of → :debug :info :warning :error
  (when (<= *log-level* (or (pos level '(:debug :info :warning :error)) 0))
    (let ((log-msg
	   (cons
	    (concat "%s " (format-time-string "%H:%M:%S "
(apply 'encode-time (butlast (decode-time (current-time)) 3)))
		    fstr)
	    (cons (symbol-name level) args))))
      (file-acc-push (apply #'format log-msg))
      (apply #'message log-msg)) nil))
#+END_SRC
where I inserted =nil= at the end just for convenience, since I often use
=clog= for error messages:
#+BEGIN_SRC emacs-lisp
(if (we-got-problems)
(clog :error "we've got %d problems!" 1000)
(the-rest-of-code))
#+END_SRC
← in case of "problems" I want this code block to return =nil=.

Let us not forget to flush the log
#+BEGIN_SRC emacs-lisp :tangle generated/logging.el
(defun on-emacs-exit()
  (clog :debug "flushing comments before quiting emacs")
  (clog-flush))
#+END_SRC
before quitting emacs:
#+BEGIN_SRC emacs-lisp :tangle generated/logging.el
(add-hook 'kill-emacs-hook 'on-emacs-exit)
#+END_SRC
* common lisp
** iff
#+BEGIN_SRC lisp :tangle generated/macros.lisp
(defmacro iff (test-form then &rest else)
  "elisp-kind of if"
  (if (cdr else)
      `(if ,test-form ,then (progn ,@else))
      (if (car else)
	  `(if ,test-form ,then ,@else)
	  `(when ,test-form ,then))))
#+END_SRC

#+BEGIN_SRC lisp :results drawer
(macroexpand-1 '(iff 1 2))
#+END_SRC

#+RESULTS:
:RESULTS:
(WHEN 1 2)
T
:END:

#+BEGIN_SRC lisp :results drawer
(macroexpand-1 '(iff 1 2 3))
#+END_SRC

#+RESULTS:
:RESULTS:
(IF 1
    2
    3)
T
:END:

#+BEGIN_SRC lisp :results drawer
(macroexpand-1 '(iff 1 2 3 4))
#+END_SRC

#+RESULTS:
:RESULTS:
(IF 1
    2
    (PROGN 3 4))
T
:END:

** simple stuff
#+BEGIN_SRC lisp :tangle generated/macros.lisp
(defmacro ifn (test ifnot &rest ifyes)
`(iff (not ,test) ,ifnot ,@ifyes))
#+END_SRC

#+BEGIN_SRC lisp :tangle generated/macros.lisp
(defmacro concat (&rest strs)
  `(concatenate 'string ,@strs))
#+END_SRC

#+BEGIN_SRC lisp :tangle generated/tests.lisp
(deftest concat
  (concat "/etc/" "dqoE.tmp")
"/etc/dqoE.tmp")
#+END_SRC

#+BEGIN_SRC lisp :tangle generated/macros.lisp
(defmacro aset(arr pos val)
  `(setf (aref ,arr ,pos) ,val))
#+END_SRC

#+BEGIN_SRC lisp :tangle generated/tests.lisp
(deftest aset
(aref
(let ((container (make-array 5)))
  (aset container 2 23987)
  container)
2)
23987)
#+END_SRC

#+BEGIN_SRC lisp :tangle generated/macros.lisp
(defmacro hset(arr pos val)
  `(setf (gethash ,pos ,arr) ,val))
#+END_SRC

#+BEGIN_SRC lisp :tangle generated/tests.lisp
(deftest hset
(gethash 'one-entry
(let ((container (make-hash-table)))
  (hset container 'one-entry 23987)
  container))
23987 t)
#+END_SRC

** file/directory fuctions
*** rmdir
#+BEGIN_SRC lisp :tangle generated/files.lisp
(defun rmdir(DN)
  (handler-case (cons t (sb-posix:rmdir DN))
    (sb-posix:syscall-error (c)
    (cons nil
      (case (sb-posix:syscall-errno c)
        (13 :permission)
        (2 :absent)
        (39 :occupied)
        (otherwise (cons :unknown (sb-posix:syscall-errno c))))))))
#+END_SRC
– expected to work on SBCL only.

*** echo-to-file
#+BEGIN_SRC lisp :tangle generated/files.lisp
(defun echo-to-file (FN str)
  (with-open-file (stream FN
    :if-exists :overwrite
    :direction :output
    :if-does-not-exist :create)
(format stream "~a~%" str)))
#+END_SRC

*** merge-paths = generalized merge-pathnames
#+BEGIN_SRC lisp :tangle generated/files.lisp
(defun merge-paths(root-dir &rest sub-dirs)
  (reduce
   #'(lambda(DN FN) (merge-pathnames FN (uiop:ensure-directory-pathname DN)))
   sub-dirs
   :initial-value root-dir))
#+END_SRC
