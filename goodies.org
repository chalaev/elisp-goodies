#+TITLE: eLisp macros and functions used in different projects
#+AUTHOR: Oleg Shalaev
#+EMAIL:  oleg@chalaev.com
#+LaTeX_HEADER: \usepackage[russian,english]{babel}
#+LATEX_HEADER: \usepackage[letterpaper,hmargin={1.5cm,1.5cm},vmargin={1.3cm,2cm},nohead,nofoot]{geometry}
#+KEYWORDS: emacs, elisp, macros, functions

*Note*:
Evaluation results are important part of this file, but =github= org-parser does not show them.
(BTW [[https://notabug.org/shalaev/elisp-goodies/src/master/goodies.org][notabug does show them]] although unformatted.)
Consider opening this file in ~emacs~ instead of watching it online.

* emacs configuration in ~/.emacs
You probably want to adjust this code to your needs before pasting it into your =~/.emacs=:
#+BEGIN_SRC emacs-lisp :tangle generated/dot.emacs :shebang ";; -*- mode: Emacs-Lisp;  lexical-binding: t; -*-"
;; Generated from https://notabug.org/shalaev/elisp-goodies/src/master/goodies.org
;; See explanations therein. Edit this code before using it.

(defun barename (FN)
  (let ((SS (split-string (file-name-nondirectory FN)  "\\." t)))
    (mapconcat #'(lambda(x)x) (butlast SS) ".")))
#+END_SRC

Obsoleted by =file-name-nondirectory=:
#+BEGIN_SRC 
(defun basename (FN) (car(last(split-string FN "/" t))))
#+END_SRC

The following function is designed to prevent multiple evaluation of one and the same file:
#+BEGIN_SRC emacs-lisp :tangle generated/dot.emacs
(defvar *loaded* nil "prevents duplicate evaluation of files")
(defun load-file* (x &optional el-prefix)
  (let ((FN (file-chase-links 
             (if (= ?/ (aref x 0)) x
               (concat (or el-prefix 
 (concat (getenv "HOME") "/"))
x)))))
    (unless (member (car (last (split-string FN "\\." t))) '("el" "elc"))
      (setf FN (concat FN ".el")))
    (unless (member FN *loaded*) (load-file FN) (push (barename FN) *loaded*))))
#+END_SRC
Every time I start emacs, I load several files:
#+BEGIN_SRC emacs-lisp :tangle generated/dot.emacs
(mapcar #'(lambda(x) (load-file* x "~/programming/emacs/"))
	'("macros" "functions" "logging"  ....))
#+END_SRC

My ~backup~ system does not save files having the group ~tmp~.
I use this group to mark all generated (tangled) files:
#+BEGIN_SRC emacs-lisp :tangle generated/dot.emacs
(defun after-tangle()
  "mark tangled files as non-backupable (chgrp tmp files) and non-excecutable"
  (let ((FN (buffer-file-name)))
#+END_SRC
The following line is equivalent to =chmod a-x FN=:
#+BEGIN_SRC emacs-lisp :tangle generated/dot.emacs
    (set-file-modes FN (logand #o666 (perms-from-str (nth 8 (file-attributes FN 'string)))))
    (chgrp "tmp" FN)))
(add-hook 'org-babel-post-tangle-hook #'after-tangle)
#+END_SRC
so they are not backuped.

* replacing cl.el
Just following Stallman's advice, I try to avoid using =cl.el=;
=generated/cl.el= will be my (incomplete for now) replacement for  =cl.el=
to be loaded as follows:
#+BEGIN_SRC emacs-lisp
(unless (functionp 'gensym)
  (load "generated/cl.el"))
#+END_SRC

*Problem:* I am not sure if eliminating =cl.el= really makes sence because
apparently it is widely used; for example, =M-x org-babel-tangle= uses =cl.el= (although does not require it).

** gensym
#+BEGIN_SRC emacs-lisp :tangle generated/cl.el :shebang ";; -*- mode: Emacs-Lisp;  lexical-binding: t; -*-"
;; generated from https://notabug.org/shalaev/elisp-goodies/src/master/goodies.org
(let ((counter 0))
  (defun gensym(&optional starts-with)
    "for those who miss gensym from Common Lisp"
    (unless starts-with (setf starts-with "gs"))
    (let (sym)
      (while (progn
               (setf sym (make-symbol (concat starts-with (number-to-string counter))))
               (or (special-form-p sym) (functionp sym) (macrop sym) (boundp sym)))
        (incf counter))
      (incf counter)
      sym)))
#+END_SRC
=gensym= is used in macros, e.g.
#+BEGIN_SRC emacs-lisp :results drawer
(let ((ms (gensym "a")))
  `(let ((,ms 0))
     (1+ ,ms)))
#+END_SRC

#+RESULTS:
:RESULTS:
(let ((a3 0)) (1+ a3))
:END:

** find
#+BEGIN_SRC emacs-lisp :tangle generated/cl.el
(defun find(item seq &optional key test)
  (when seq
  (let ((test (or test #'=)))
    (when-let ((CS (car seq)))
      (if-let ((found (funcall test
			       item
			       (if key (funcall key CS) CS))))
	  CS
	(find item (cdr seq) key test))))))
#+END_SRC

#+BEGIN_SRC emacs-lisp :results drawer
(find 3 '( 1 2 3 4 5))
#+END_SRC

#+RESULTS:
:RESULTS:
3
:END:

#+BEGIN_SRC emacs-lisp :results drawer
(find 4 '((1 2) (3 4) (5 6)) #'cadr)
#+END_SRC

#+RESULTS:
:RESULTS:
(3 4)
:END:

** decf and incf
#+BEGIN_SRC emacs-lisp :tangle generated/cl.el
(unless (or (boundp 'decf) (functionp 'decf) (macrop 'decf))
(defmacro decf (var &optional amount)
  (unless amount (setf amount 1))
  `(setf ,var (- ,var ,amount))))
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle generated/cl.el
(unless (or (boundp 'incf) (functionp 'incf) (macrop 'incf))
(defmacro incf (var &optional amount)
  (unless amount (setf amount 1))
  `(setf ,var (+ ,var ,amount))))
#+END_SRC

** flet
It uses =macrolet= which is also defined in  =cl.el= :)

#+BEGIN_SRC emacs-lisp :tangle generated/cl.el
(defmacro flet(fun-defs &rest body)
(let ((GSs (mapcar #'(lambda(FD) (cons (car FD) (gensym))) fun-defs)))
`(let ,(mapcar #'(lambda(FD)
(list (cdr (assoc (car FD) GSs))
`(lambda ,(cadr FD) ,@(cddr FD)))) fun-defs)
(macrolet ,(mapcar #'(lambda(FD)
(list (car FD) (cadr FD) `(funcall ,(cdr (assoc (car FD) GSs)) ,@(cadr FD)))) fun-defs)
 ,@body))))
#+END_SRC

#+BEGIN_SRC emacs-lisp :results drawer
(print (macroexpand-1 '(flet ((f1(x) (1+ x)) (f2(x) (1- x)))
(+ 1 2 (f1 3))
(* 1 2 (f2 3)))))
#+END_SRC

#+RESULTS:
:RESULTS:
(let ((G38 (lambda (x) (1+ x)))
      (G39 (lambda (x) (1- x))))
(macrolet ((f1 (x) (funcall G38 x)) 
           (f2 (x) (funcall G39 x)))
 (+ 1 2 (f1 3))
 (* 1 2 (f2 3))))
:END:

To be improved: variable names in =macrolet= should be generated by =gensym=.

* short pieces of code
** case*
~case*~ is not identical to =case= from =cl.el=:
it uses arbitrary test function:
#+BEGIN_SRC emacs-lisp :tangle generated/macros.el :shebang ";; -*- mode: Emacs-Lisp;  lexical-binding: t; -*-"
;; generated from https://notabug.org/shalaev/elisp-goodies/src/master/goodies.org
(defmacro case* (expr test &rest cases)
  "case with arbitrary test function"
  (let ((v (gensym "v")))
    `(let ((,v ,expr))
       (cond
        ,@(mapcar #'(lambda (VR)
(let ((val (car VR)) (rest (cdr VR)))
  (if (eql val 'otherwise)
      `(t ,@rest)
    `((,test ,v ,val) ,@rest))))
 cases)))))
#+END_SRC
A simple example:
#+BEGIN_SRC emacs-lisp :results drawer
(macroexpand-1 
 `(case* (+ 1 2) =
    (choice-1 (message "choice-1"))
    (choice-2 (message "choice-2"))
    (otherwise (message "no match"))))
#+END_SRC

#+RESULTS:
:RESULTS:
(let ((v13 (+ 1 2)))
 (cond 
((= v13 choice-1) (message choice-1))
((= v13 choice-2) (message choice-2))
(t (message no match))))
:END:

Another example is also self-explanatory:
#+BEGIN_SRC emacs-lisp :results drawer
(let ((x 32) (choice-1 22)  (choice-2 33))
  (case* (1+ x) =
    (choice-1 (message "choice-1"))
    (choice-2 (message "choice-2"))
    (otherwise (message "no match"))))
#+END_SRC

#+RESULTS:
:RESULTS:
choice-2
:END:

** case-let
Sometimes we may want to access the let-variable name generated in =case*=;
so we define =case-let= which is only a slightly modified version of =case*=:
#+BEGIN_SRC emacs-lisp :tangle generated/macros.el
(defmacro case-let (let-var expr test &rest cases)
  "case* with let expriable named by the user"
    `(let ((,let-var ,expr))
       (cond
        ,@(mapcar #'(lambda (VR)
(let ((val (car VR)) (rest (cdr VR)))
  (if (eql val 'otherwise)
      `(t ,@rest)
    `((,test ,let-var ,val) ,@rest))))
 cases))))
#+END_SRC
A simple example:
#+BEGIN_SRC emacs-lisp :results drawer
(macroexpand-1 
 `(case-let x (+ 1 2) =
    (choice-1 (format "1: x=%d" x))
    (choice-1 (format "2: x=%d" x))
    (otherwise (message "no match"))))
#+END_SRC

#+RESULTS:
:RESULTS:
(let ((x (+ 1 2))) (cond ((= x choice-1) (format 1: x=%d x)) ((= x choice-1) (format 2: x=%d x)) (t (message no match))))
:END:

** chgrp
#+BEGIN_SRC emacs-lisp :tangle generated/file-functions.el :shebang ";; -*- mode: Emacs-Lisp;  lexical-binding: t; -*-"
;; generated from https://notabug.org/shalaev/elisp-goodies/src/master/goodies.org
(defun chgrp(group file-name)
  (= 0 (call-process "chgrp" nil nil nil group file-name)))
#+END_SRC
See also =dired-do-chown=.

** when-let
=when-let= is one of my most-used macros:
#+BEGIN_SRC emacs-lisp :tangle generated/macros.el
(defmacro when-let (vars &rest body)
  "when with let using stndard let-notation"
  (if (caar vars)
  `(let ((,(caar vars) ,(cadar vars)))
     ,(if (cdr vars)
	  `(when ,(caar vars)
	     ,(macroexpand-1 `(when-let ,(cdr vars) ,@body)))
	(append `(when ,(caar vars)) body)))
  (if (cdr vars)
      `(when ,(cadar vars)
	     ,(macroexpand-1 `(when-let ,(cdr vars) ,@body)))
    (append `(when ,(cadar vars)) body))))
#+END_SRC
Using standard let*-syntax, it evaluates varibales in the header one after another,
and, if they are all non-nil, evalueates the body:
#+BEGIN_SRC emacs-lisp :results drawer
(print (macroexpand-1 
  '(when-let ((x 1) (y (1+ x)))
       (incf x y) (incf y x))))
#+END_SRC

#+RESULTS:
:RESULTS:
(let ((x 1)) (when x (let ((y (1+ x))) (when y (incf x y) (incf y x)))))
:END:

If we put =nil= instead of the variable name, no local varibale will be created for this entry:
#+BEGIN_SRC emacs-lisp :results drawer
(print (macroexpand-1
 `(when-let ((CN (clouded (aref newDBrec cipher))) (nil (not (file-exists-p CN))))
    (+ 1 2)
    (- 1 2))))
#+END_SRC

#+RESULTS:
:RESULTS:
(let ((CN (clouded (aref newDBrec cipher)))) (when CN (when (not (file-exists-p CN)) (+ 1 2) (- 1 2))))
:END:
– this double =when= is ugly and inefficient, but for ~elisp~ it is probably o.k. because we do not need as much efficiency here, as in Common Lisp.

Later I wrote [[needs]] which is more general than =when-let=, and can replace it.

** when-set and unless-set
Sometimes instead of =when-let= I use somewhat similar =when-set= macro.
=when-set= is similar to =when-let= except for that it uses existing global variables instead of creating local ones.

Note that the value of the global variable will *not* be set to ~nil~.

#+BEGIN_SRC emacs-lisp :tangle generated/macros.el
(defmacro when-set (vars &rest body)
  "when-let using global variable instead of defining local one"
(let ((GV (gensym)))
  `(let ((,GV ,(cadar vars)))
     ,(if (cdr vars)
	  `(when ,GV
              (setf ,(caar vars) ,GV)
	     ,(macroexpand-1 `(when-set ,(cdr vars) ,@body)))
	(append `(when ,GV (setf ,(caar vars) ,GV)) body)))))
#+END_SRC

#+BEGIN_SRC emacs-lisp :results drawer
(print (macroexpand-1
 `(when-set ((CN (clouded (aref newDBrec cipher))) (NFE (not (file-exists-p CN))))
    (+ 1 2)
    (- 1 2))))
#+END_SRC

#+RESULTS:
:RESULTS:
(let ((it15 (clouded (aref newDBrec cipher))))
 (when it15 (setf CN it15) 
   (let ((it16 (not (file-exists-p CN))))
      (when it16 (setf NFE it16) (+ 1 2) (- 1 2)))))
:END:

=unless-set= is similar to =when-set=:
#+BEGIN_SRC emacs-lisp :tangle generated/macros.el
(defmacro unless-set (vars &rest body)
  "unless-let using global variable instead of defining local one"
(let ((GV (gensym)))
  `(let ((,GV ,(cadar vars)))
     ,(if (cdr vars)
	  `(if ,GV
              (setf ,(caar vars) ,GV)
	     ,(macroexpand-1 `(unless-set ,(cdr vars) ,@body)))
	(append `(if ,GV (setf ,(caar vars) ,GV)) body)))))
#+END_SRC

#+BEGIN_SRC emacs-lisp :results drawer
(print (macroexpand-1
 `(unless-set ((CN (aref newDBrec cipher)) (FE (file-exists-p CN)))
    (+ 1 2)
    (- 1 2))))
#+END_SRC

#+RESULTS:
:RESULTS:
(let ((g30 (aref newDBrec cipher)))
  (if g30
     (setf CN g30) 
(let ((g31 (file-exists-p CN)))
    (if g31 (setf FE g31)
       (+ 1 2)
       (- 1 2)))))
:END:

** if-let
Like =when-let=, macro =if-let= is heavily used in my projects.
It is somewhat similar to =when-let=, but offers "else" clause:
#+BEGIN_SRC emacs-lisp :tangle generated/macros.el
(defmacro if-let (vars &rest body)
  "if with let using stndard let-notation"
  (let ((if-true (gensym "it")) (result (gensym "r")))
    `(let (,if-true ,result)
       (when-let ,vars
		 (setf ,if-true t)
		 (setf ,result ,(car body)))
       (if ,if-true
	   ,result
	 ,@(cdr body)))))
#+END_SRC

Usage example:
#+BEGIN_SRC emacs-lisp :results drawer
(print (macroexpand-1 
  '(if-let ((x 1) (y (1+ x)))
     (+ x y) (- x y) (* x y))))
#+END_SRC

#+RESULTS:
:RESULTS:
(let (it27) (when-let ((x 1) (y (1+ x))) (setf it27 t) (+ x y)) (unless it27 (- x y) (* x y)))
:END:

Sometimes I need slightly changed versions of =if-let=:
#+BEGIN_SRC emacs-lisp :tangle generated/macros.el
(defmacro ifn-let (vars &rest body)
  `(if-let ,vars
      ,(cons 'progn (cdr body))
    ,(car body)))
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle generated/macros.el
(defmacro ifn-set (vars &rest body)
  `(if-set ,vars
      ,(cons 'progn (cdr body))
    ,(car body)))
#+END_SRC

#+BEGIN_SRC emacs-lisp :results drawer
(print (macroexpand-1 (macroexpand-1 
'(ifn-set
  ((remote/files (cdr (assoc "remote/files" conf)))
   (N-CPU-cores (string-to-number (or (cdr (assoc "number-of-CPU-cores" conf)) "1")))
   (password  (cdr (assoc "password" conf)))
   (remote-dir (cdr (assoc "remote-directory" conf))))
(clog :error "something is missing or wrong in the configuration file" remote-dir)
(print "everything is ok")
(print "so we proceed")))))
#+END_SRC

#+RESULTS:
:RESULTS:
(let (it32 r33) 
  (setf r33
	(when-set ((remote/files (cdr (assoc remote/files conf)))
		   (N-CPU-cores (string-to-number (or (cdr (assoc number-of-CPU-cores conf)) 1)))
		   (password (cdr (assoc password conf)))
		   (remote-dir (cdr (assoc remote-directory conf))))
		  (setf it32 t)
		  (progn (print everything is ok) (print so we proceed))))
  (if it32
      r33
    (clog :error something is missing or wrong in the configuration file remote-dir)))
:END:

** if-set
#+BEGIN_SRC emacs-lisp :tangle generated/macros.el
(defmacro if-set (vars &rest body)
  (let ((if-true (gensym "it")) (result (gensym "r")))
    `(let (,if-true ,result)
       (setf ,result (when-set ,vars
		  (setf ,if-true t)
		  ,(car body)))
       (if ,if-true ,result
	 ,@(cdr body)))))
#+END_SRC

#+BEGIN_SRC emacs-lisp :results drawer
(print (macroexpand-1
  '(if-set ((x 1) (y (1+ x)))
     (+ x y) (- x y) (* x y))))
#+END_SRC

#+RESULTS:
:RESULTS:
(let (it28 r29) 
(setf r29 (when-set ((x 1) (y (1+ x))) (setf it28 t) (+ x y)))
 (if it28 r29 (- x y) (* x y)))
:END:

** cond-let
=cond-let= is a natural generalization of =if-let=:
#+BEGIN_SRC emacs-lisp :tangle generated/macros.el
(defmacro cond-let (&rest conds)
  "cond with let"
  (let ((c (car conds)) (r (cdr conds)))
    (if (equal (car c) 'otherwise) (cons 'progn (cdr c))
    (if r
	`(if-let ,(car c) ,(cons 'progn (cdr c)) ,(macroexpand-1 `(cond-let ,@r)))
	`(when-let ,(car c) ,@(cdr c))))))
#+END_SRC

#+BEGIN_SRC emacs-lisp :results drawer
(print (macroexpand-1
  '(cond-let
    (((x 1) (y (1+ x))) (+ x y) (- x y) (* x y))
    (((x 3) (y (1+ x))) (+ x y) (- x y) (/ x y))
    (otherwise 22 33))))
#+END_SRC

#+RESULTS:
:RESULTS:
(if-let ((x 1) (y (1+ x))) (progn (+ x y) (- x y) (* x y)) (if-let ((x 3) (y (1+ x))) (progn (+ x y) (- x y) (/ x y)) (progn 22 33)))
:END:

Formatted result:
#+BEGIN_SRC emacs-lisp
(if-let ((x 1) (y (1+ x)))
  (progn (+ x y) (- x y) (* x y))
  (if-let ((x 3) (y (1+ x))) 
    (progn (+ x y) (- x y) (/ x y))
    (progn 22 33)))
#+END_SRC

** needs
New =needs= macro is gradually replacing =when-let=:

#+BEGIN_SRC emacs-lisp :tangle generated/macros.el
(defmacro needs (vardefs &rest body)
  "unifying when-let and if-let"
  (let ((vardef (car vardefs)))
    (if (and (listp vardef) (not (or (special-form-p (car vardef)) (functionp (car vardef)) (macrop (car vardef)))))
    `(let ((,(car vardef) ,(cadr vardef)))
       ,(if (cddr vardef)
	    `(if ,(car vardef)
		,(if (cdr vardefs)
		     (macroexpand-1 `(needs ,(cdr vardefs) ,@body))
		   `(progn ,@body))
	       ,(car (cddr vardef)))
	  (append `(when ,(car vardef))
		  (if (cdr vardefs)
		      (list (macroexpand-1 `(needs ,(cdr vardefs) ,@body)))
		    body))))
    (append `(when ,vardef)
		  (if (cdr vardefs)
		      (list (macroexpand-1 `(needs ,(cdr vardefs) ,@body)))
		    body)))))
#+END_SRC
=needs= acts similarly to =when-let= except that for every variable decalared in its header
it has an optional third argument – a form to be evaluated in case the variable turns out to be ~nil~.

#+BEGIN_SRC emacs-lisp :results drawer
(print (macroexpand-1 '(needs
((x (f 1) (message "could not define x"))
 (y (g x) (message "could not define y")))
(message "let's rock")
(- x y))))
#+END_SRC

#+RESULTS:
:RESULTS:
(let ((x (f 1))) (if x (let ((y (g x))) (if y (progn (message let's rock) (- x y)) (message could not define y))) (message could not define x)))
:END:

← let me format the output:
#+BEGIN_SRC emacs-lisp
(let ((x (f 1)))
  (if x
      (let ((y (g x)))
	(if y
	    (progn
	      (message "let's rock")
	      (- x y))
	  (message "could not define y")))
    (message could "not define x")))
#+END_SRC


For other usage examples, see [[https://github.com/chalaev/cloud][cloud]] project, e.g.:
#+BEGIN_SRC emacs-lisp :results drawer
(print (macroexpand-1 '(needs ((col-value (begins-with str (car column)) (bad-column "action" (cdr column))))
(aset action (cdr column) (car col-value))
(setf str (cdr col-value)))))
#+END_SRC

Sometimes I need a slightly changed version of =needs= that does not create a local variable,
setting the value of a global one instead:
#+BEGIN_SRC emacs-lisp :tangle generated/macros.el
(defmacro first2(ll) `(firstN ,ll 2))
(defmacro needs-set (vardefs &rest body)
  "needs with 'let' being replaced with 'setf'"
  (let ((vardef (car vardefs)))
    (if (cddr vardef)
      `(if-set (,(first2 vardef))
	  ,(if (cdr vardefs)
	       (macroexpand-1 `(needs-set ,(cdr vardefs) ,@body))
	     (cons 'progn body))
	  ,(caddr vardef))
      `(when-set (,(car vardefs))
	   ,(if (cdr vardefs)
	       (macroexpand-1 `(needs-set ,(cdr vardefs) ,@body))
	      (cons 'progn body))))))
#+END_SRC

Example #1:
#+BEGIN_SRC emacs-lisp :results drawer
(print (macroexpand-1 '(needs-set
((x (f 1) (message "did not set x"))
 (y (g x) (message "did not set y")))
(message "let's rock")
(- x y))))
#+END_SRC

#+RESULTS:
:RESULTS:
(if-set ((x (f 1))) (if-set ((y (g x))) (progn (message let's rock) (- x y)) (message did not set y)) (message did not set x))
:END:

and here is the formatted result:
#+BEGIN_SRC emacs-lisp
(if-set ((x (f 1)))
  (if-set ((y (g x)))
     (progn
       (message let's rock)
       (- x y))
     (message "did not set y"))
  (message "did not set x"))
#+END_SRC

Example #2 (from the [[https://github.com/chalaev/cloud][cloud project]]):
#+BEGIN_SRC emacs-lisp :results drawer
(print (macroexpand-1 '(needs-set
  ((conf (read-conf* (local/config)))
   (remote/files (cdr (assoc "remote/files" conf)) (clog :error "specify 3-symbol contents name (remote/files) in %s" (local/config)))
   (N-CPU-cores (string-to-number
 (or
 (cdr (assoc "number-of-CPU-cores" conf))
 (clog :warning "specify number-of-CPU-cores in %s" (local/config)
 "1"))))
   (password (cdr (assoc "password" conf)) (clog :error "specify password in %s" (local/config)))
   (remote-dir (cdr (assoc "remote-directory" conf)) (clog :error "specify remote-directory in %s" (local/config))))
conf)))
#+END_SRC

#+RESULTS:
:RESULTS:
(when-set ((conf (read-conf* (local/config)))) (if-set ((remote/files (cdr (assoc remote/files conf)))) (when-set ((N-CPU-cores (string-to-number (or (cdr (assoc number-of-CPU-cores conf)) (clog :warning specify number-of-CPU-cores in %s (local/config) 1))))) (if-set ((password (cdr (assoc password conf)))) (if-set ((remote-dir (cdr (assoc remote-directory conf)))) (progn conf) (clog :error specify remote-directory in %s (local/config))) (clog :error specify password in %s (local/config)))) (clog :error specify 3-symbol contents name (remote/files) in %s (local/config))))
:END:
and here is the formatted result:
#+BEGIN_SRC emacs-lisp
(when-set ((conf (read-conf* (local/config))))
  (if-set ((remote/files (cdr (assoc remote/files conf))))
    (when-set ((N-CPU-cores (string-to-number (or (cdr (assoc number-of-CPU-cores conf)) (clog :warning specify number-of-CPU-cores in %s (local/config) 1)))))
      (if-set ((password (cdr (assoc password conf))))
        (if-set ((remote-dir (cdr (assoc remote-directory conf))))
	  (progn conf)
	  (clog :error specify remote-directory in %s (local/config)))
	(clog :error specify password in %s (local/config))))
    (clog :error specify 3-symbol contents name (remote/files) in %s (local/config))))
#+END_SRC

** email
A non-interactive =email= function:
#+BEGIN_SRC emacs-lisp :tangle generated/functions.el :shebang ";; -*- mode: Emacs-Lisp;  lexical-binding: t; -*-"
(defun email (addr &optional subject body)
  "fast non-interactive way to send an email"
  (compose-mail addr (if subject subject ""))
  (when body (insert body))
  (message-send-and-exit))
#+END_SRC
– will work if mailing system (~exim4~ in my case) is configured properly.

** pos
Position of an element in a list:
#+BEGIN_SRC emacs-lisp :tangle generated/functions.el
(defun pos (el ll)
  (let ((i 0) r)
  (dolist (e ll r)
    (if (eql e el)
	(setf r i)
      (incf i)))))
#+END_SRC

** remo & drop
Remo is a helper for =drop= macro which removes elements from an array:
#+BEGIN_SRC emacs-lisp :tangle generated/functions.el
(defun remo (from-where &rest what)
  (if (cdr what)
      (remo
       (apply #'remo (cons from-where (cdr what)))
       (car what))
 (remove (car what) from-where)))
(defmacro drop (from-where &rest what)
  `(setf ,from-where (remo ,from-where ,@what)))
#+END_SRC
Test:
#+BEGIN_SRC emacs-lisp :results drawer
(let ((ll '(1 2 3 4 5 6)))
  (drop ll 2 4)
  ll)
#+END_SRC

#+RESULTS:
:RESULTS:
(1 3 5 6)
:END:

** perms-from-str
When I ask ~emacs~ to show me file's permissions, it provides a text string (e.g., "-rw-rw----") instead of a number.
The following function produces a number from such a string:
#+BEGIN_SRC emacs-lisp :tangle generated/functions.el
(defun perms-from-str (str)
"parses file mode string into integer"
  (let ((text-mode (reverse (cdr (append str nil)))) (mode 0) (fac 1))
    (loop for c in text-mode for i from 0
          unless (= c ?-) do (incf mode fac)
          do (setf fac (* 2 fac)))
    mode))
#+END_SRC
Usage example:
#+BEGIN_SRC emacs-lisp :results drawer
(perms-from-str "-rw-rw----")
#+END_SRC

#+RESULTS:
:RESULTS:
432
:END:

** perms-to-str
=perms-to-str= is just the opposite of [[perms-from-str]].
#+BEGIN_SRC emacs-lisp :results drawer
(let ((ll '((1 . 0))))
  (dotimes (i 8 ll)
     (push (cons (* 2 (caar ll)) (mod (1+ i) 3))  ll)))
#+END_SRC

#+RESULTS:
:RESULTS:
((256 . 2) (128 . 1) (64 . 0) (32 . 2) (16 . 1) (8 . 0) (4 . 2) (2 . 1) (1 . 0))
:END:

#+BEGIN_SRC emacs-lisp :results drawer
(let ((ll '((1 . 0))))
  (dotimes (i 8 ll)
     (push (cons (* 2 (caar ll)) (mod (1+ i) 3))  ll)))
#+END_SRC

#+RESULTS:
:RESULTS:
((256 . 2) (128 . 1) (64 . 0) (32 . 2) (16 . 1) (8 . 0) (4 . 2) (2 . 1) (1 . 0))
:END:

#+BEGIN_SRC emacs-lisp :results drawer
(let ((ll '((1 . 0))) (file-mode #o664))
  (apply #'concat (mapcar
		   #'(lambda(x) (format "%c" (if (= 0 (logand file-mode (car x))) ?- (aref "xwr" (cdr x)))))
  (dotimes (i 8 ll)
     (push (cons (* 2 (caar ll)) (mod (1+ i) 3))  ll)))))
#+END_SRC

#+RESULTS:
:RESULTS:
rw-rw-r--
:END:
#+BEGIN_SRC emacs-lisp :tangle generated/functions.el
(defun perms-to-str(file-mode)
"formats integer file mode into string"
(let ((ll '((1 . 0))))
  (apply #'concat (mapcar
		   #'(lambda(x) (format "%c" (if (= 0 (logand file-mode (car x))) ?- (aref "xwr" (cdr x)))))
  (dotimes (i 8 ll)
     (push (cons (* 2 (caar ll)) (mod (1+ i) 3))  ll))))))
#+END_SRC
Usage example:
#+BEGIN_SRC emacs-lisp :results drawer
(perms-to-str #o667)
#+END_SRC

#+RESULTS:
:RESULTS:
rw-rw-rwx
:END:

** parsing time and date
#+BEGIN_SRC emacs-lisp :tangle generated/functions.el
(defun parse-date (str)
  (mapcar 'string-to-number
	  (cond
 ((string-match "\\([0-9]\\{4\\}\\)[/-]\\([0-9][0-9]\\)[/-]\\([0-9][0-9]\\)" str) (mapcar #'(lambda (x) (match-string x str)) '(3 2 1)))
 ((string-match "\\([0-9][0-9]\\)[/-]\\([0-9][0-9]\\)[/-]\\([0-9]\\{4\\}\\)" str) (mapcar #'(lambda (x) (match-string x str)) '(2 1 3)))
 ((string-match "\\([0-9][0-9]\\)\\.\\([0-9][0-9]\\)\\.\\([0-9]\\{4\\}\\)" str) (mapcar #'(lambda (x) (match-string x str)) '(1 2 3)))
 ((string-match "\\([0-9][0-9]\\)/\\([0-9][0-9]\\)/\\([0-9]\\{2\\}\\)" str) (mapcar #'(lambda (x) (match-string x str)) '(2 1 3)))
 ((string-match "\\([0-9]\\{2\\}\\)[/-]\\([0-9][0-9]\\)" str) (append (mapcar #'(lambda (x) (match-string x str)) '(2 1)) (list (format-time-string "%Y" (current-time)))))
 (t (clog :error "date format not recognized in %s" str) nil))))
#+END_SRC
#+BEGIN_SRC emacs-lisp :tangle generated/functions.el
(defun parse-only-time (str)
  (firstN (parse-time-string str) 3))
#+END_SRC
#+BEGIN_SRC emacs-lisp :tangle generated/functions.el
(defun parse-date-time(str)
  (if (string-match "[0-9]\\{4\\}-[0-9][0-9]-[0-9][0-9] [0-9][0-9]:[0-9][0-9]" str)
      (parse-time-string str)
    (let ((SS (split-string str)))
      (append (parse-only-time (cadr SS))
	      (parse-date (car SS))))))
#+END_SRC
Example:
#+BEGIN_SRC emacs-lisp :results drawer
(cons (parse-only-time "16:09:37")
(mapcar #'(lambda(x) (format-time-string "%F %H:%M:%S %Z" (apply #'encode-time (parse-date-time x))))
 (list "10/21 14:54"
        "2020-10-10 14:54:40  EDT")))
#+END_SRC

#+RESULTS:
:RESULTS:
((37 9 16) 2020-10-21 14:54:00 EDT 2020-10-10 14:54:40 EDT)
:END:

** directory-lock
=directory-lock= attempts to create directory =locked-dir=.

If the subdirectory was sucessfully created,
1. file "by" is created there containing the string ~by~, and
2. forms ~body~ are evaluated.

=directory-lock= returns =cons=; its =car= is ~t~ in case
all =directory-lock= operations went through successfully:
the directory was successfully locked and later unlocked;
in this case, =cdr= contains the result of ~body~ evaluation.

#+BEGIN_SRC emacs-lisp :tangle generated/macros.el
(defmacro directory-lock(locked-dir by &rest body)
(let ((LD0 (gensym "ld0-")) (LD1 (gensym "ld1-")) (lock-file (gensym "lf")) (mkdir (gensym "md")) (result (gensym "r")) (unlock (gensym "u")))
#+END_SRC
Adding slash symbol at the end of =locked-dir= if necessary:
#+BEGIN_SRC emacs-lisp :tangle generated/macros.el
`(let* ((,LD0 ,locked-dir)
        (,LD1 (if (= ?/ (aref (reverse ,LD0) 0)) ,LD0 (concat ,LD0 "/")))
        (,lock-file (concat ,LD1 "by"))
        (,mkdir (safe-mkdir ,LD1)))
  (ifn (car ,mkdir) (cons nil ,mkdir)
  (write-region ,by nil ,lock-file)
  (let ((,result (progn ,@body)))
    (if-let ((,unlock (and (safe-delete-file ,lock-file) (safe-delete-dir ,LD1))))
      (cons t ,result)
      (cons nil (cons ,unlock ,result))))))))
#+END_SRC

If something went wrong, =(car (directory-lock ...))= is =nil=,
and the problem is described by =(cadr (directory-lock ...))= which is
- ~:lock~ in case the directory could not be locked, or
- ~:unlock~ in case the directory could not be unlocked. That is, we were able to create the directory ~locked-dir~,
  then evaluated the ~body~ forms, but finally could not erase ~locked-dir~.

Example – locking remote directory: 
#+BEGIN_SRC emacs-lisp :results drawer
(print (macroexpand-1 '(directory-lock "/mnt/server/code-name" (system-name)
(body-1) (body-2))))
#+END_SRC

#+RESULTS:
:RESULTS:
(let* ((ld0-58 /mnt/server/code-name) (ld1-59 (if (= 47 (aref (reverse ld0-58) 0)) ld0-58 (concat ld0-58 /))) (lf60 (concat ld1-59 by)) (md61 (safe-mkdir ld1-59))) (ifn (car md61) (cons nil md61) (write-region (system-name) nil lf60) (let ((r62 (progn (body-1) (body-2)))) (if-let ((u63 (and (safe-delete-file lf60) (safe-delete-dir ld1-59)))) (cons t result) (cons nil (cons u63 r62))))))
:END:

Formatted result:
#+BEGIN_SRC
(let* ((ld0-58 "/mnt/server/code-name")
       (ld1-59 (if (= 47 (aref (reverse ld0-58) 0)) ld0-58 (concat ld0-58 "/")))
       (lf60 (concat ld1-59 "by"))
       (md61 (safe-mkdir ld1-59)))
  (ifn (car md61) (cons nil md61)
    (write-region (system-name) nil lf60)
    (let ((r62 (progn (body-1) (body-2))))
      (if-let ((u63 (and (safe-delete-file lf60) (safe-delete-dir ld1-59))))
	  (cons t r62)
	(cons nil (cons u63 r62))))))
#+END_SRC

** simple stuff
#+BEGIN_SRC emacs-lisp :tangle generated/macros.el
(defmacro ifn (test ifnot &rest ifyes)
`(if (not ,test) ,ifnot ,@ifyes))
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle generated/functions.el
(defun firstN(lista N)
  "returning first N elments of the list"
  (when (and (< 0 N) (car lista))
    (cons (car lista) (firstN (cdr lista) (1- N)))))
#+END_SRC

*** safe-mkdir
=safe-mkdir= is a condition-free wrapper on top of =make-directory=.

Its argument ~dirname~ 
- may start with "~/" and
- may or may not and with "/".

It returns =cons=; its =car= is
- ~nil~ in case the directory can not be created (then =cdr= explains why), or
- ~t~ in case the directory was sucessfully created.

#+BEGIN_SRC emacs-lisp :tangle generated/file-functions.el
(defun safe-mkdir (dirname)
  (if (file-exists-p dirname)
    (cons nil (if (file-directory-p dirname) :exists :file))
    (condition-case err
        (progn (make-directory dirname) (list t))
      (file-already-exists (cons nil :strange))
      (file-error (cons nil :permission)))))
#+END_SRC
Returns ~(t)~ when succeeds.

*** safe-delete-file
=safe-delete-file= is a condition-free wrapper on top of =delete-file=.
Its return result is similar to that of =safe-mkdir=
#+BEGIN_SRC emacs-lisp :tangle generated/file-functions.el
(defun safe-delete-file (FN)
  (condition-case err (progn (delete-file FN) (list t))
    (file-error (cons nil (error-message-string err)))))
#+END_SRC
except that removal of nonexistent file does not lead to an error.

Example #1 – removing file with insufficient permissions produces "permission denied" error:
#+BEGIN_SRC emacs-lisp :results drawer
(safe-delete-file  "/bin/ls")
#+END_SRC

#+RESULTS:
:RESULTS:
(nil . Removing old name: Permission denied, /bin/ls)
:END:

Example #2 – removing nonexistent file produces no error:
#+BEGIN_SRC emacs-lisp :results drawer
(safe-delete-file  "/bin/there-is-no-such-file")
#+END_SRC

#+RESULTS:
:RESULTS:
(t)
:END:

Example #3 – an attempt to remove a directory produces an error:
#+BEGIN_SRC emacs-lisp :results drawer
(safe-delete-file  "/tmp")
#+END_SRC

#+RESULTS:
:RESULTS:
(nil . Removing old name: is a directory: /tmp)
:END:

To (non-recursively) remove a directory, one can use =safe-delete-dir= instead:

*** safe-delete-dir
Non-recursive directory removal.

Its return result is similar to that of =safe-delete-file= and =safe-mkdir=:
#+BEGIN_SRC emacs-lisp :tangle generated/file-functions.el
(defun safe-delete-dir (FN)
  (condition-case err (progn (delete-directory FN) (list t))
    (file-error (cons nil (error-message-string err)))))
#+END_SRC

* logging system
It is probably too small to be packaged.
** Short description
This code prints log messages to ~*Messages*~ buffer and saves them to log file =~/.emacs.d/elisp.log=.
Every message is formatted similarly to how it is done by =format= function.
** Code
Global variable =*log-level*= controls how much information should be logged: the (default) zero value means
that all types of log-messages (:debug :warning :info :error) should be logged (saved);
the value 3 means that only error messages (marked with :error) will be logged:
#+BEGIN_SRC emacs-lisp :tangle generated/logging.el :shebang ";; -*- mode: Emacs-Lisp;  lexical-binding: t; -*-"
;; generated from https://notabug.org/shalaev/elisp-goodies/src/master/goodies.org
(unless (boundp '*log-level*) (defvar *log-level* 0))
(unless (boundp '*emacs-d*) (defvar *emacs-d* (concat (getenv "HOME") "/.emacs.d/")))
#+END_SRC
Log messages are accumulated in =*file-acc-buffer*=
#+BEGIN_SRC emacs-lisp :tangle generated/logging.el
(unless (boundp '*file-acc-buffer*) (defvar *file-acc-buffer* nil))
(defvar *last-FLD* nil "saves last day printed to the log file")
#+END_SRC
and once in a while (when the number of queued messages >30 or before quitting ~emacs~) appended to the file =~/.emacs.d/elisp.log=:
#+BEGIN_SRC emacs-lisp :tangle generated/logging.el
(defun clog-flush()
  "save log messages to file for debugging"
  (when (= 0 *log-level*)
    (with-temp-buffer
      (let ((today-str (format-time-string "%04Y-%02m-%02d" (current-time))))
	(unless (string= today-str *last-FLD*)
	  (setf *last-FLD* today-str)
	  (insert today-str) (newline))
	(dolist (msg (reverse *file-acc-buffer*))
	  (insert msg) (newline)))
      (append-to-file (point-min) (point-max) (concat *emacs-d* "elisp.log")))
    (setf *file-acc-buffer* nil)))
#+END_SRC
Since we have [[https://www.emacswiki.org/emacs/EmacsLispLimitations][no multi-threading in elisp]], we do not need to introduce any lock functions.
#+BEGIN_SRC emacs-lisp :tangle generated/logging.el
(defun file-acc-push(msg)
  (push msg *file-acc-buffer*)
  (when (< 30 (length *file-acc-buffer*)) (clog-flush)))
#+END_SRC
The main logging function:
#+BEGIN_SRC emacs-lisp :tangle generated/logging.el
(defun clog (level fstr &rest args)
  "simple logging function" ; level is one of → :debug :info :warning :error
  (when (<= *log-level* (or (pos level '(:debug :info :warning :error)) 0))
    (let ((log-msg
	   (cons
	    (concat "%s " (format-time-string "%H:%M:%S "
(apply 'encode-time (butlast (decode-time (current-time)) 3)))
		    fstr)
	    (cons (symbol-name level) args))))
      (file-acc-push (apply #'format log-msg))
      (apply #'message log-msg)) nil))
#+END_SRC
where I inserted =nil= at the end just for convenience, since I often use
=clog= for error messages:
#+BEGIN_SRC emacs-lisp
(if (we-got-problems)
(clog :error "we've got %d problems!" 1000)
(the-rest-of-code))
#+END_SRC
← in case of "problems" I want this code block to return =nil=.

Let us not forget to flush the log
#+BEGIN_SRC emacs-lisp :tangle generated/logging.el
(defun on-emacs-exit()
  (clog :debug "flushing comments before quiting emacs")
  (clog-flush))
#+END_SRC
before quitting emacs:
#+BEGIN_SRC emacs-lisp :tangle generated/logging.el
(add-hook 'kill-emacs-hook 'on-emacs-exit)
#+END_SRC
